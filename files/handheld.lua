 if(var == nil) then var = {} end var.sides = {"right", "left", "up", "down", "front", "back"} var.directions = {"north", "east", "south", "west"} function string.starts(String,Start) return string.sub(String,1,string.len(Start))==Start end function string.before(String,Start) return string.sub(String,1,string.len(Start)) end function string.after(String,Start) return string.sub(String,string.len(Start) + 1) end function string.split (inputstr, sep) if sep == nil then sep = "." end local t={} for str in string.gmatch(inputstr, "([^"..sep.."]+)") do table.insert(t, str) end return t end function string.trim(s) return (string.gsub(s, "^%s*(.-)%s*$", "%1")) end function string.join(params, glue) if(glue == nil) then glue = '.' end local paramString = nil if(params ~= nil and type(params) == 'table') then for k,v in pairs(params) do if(paramString == nil) then paramString = v else paramString = paramString .. glue .. v end end else paramString = params end return paramString end function firstToUpper(str) return (str:gsub("^%l", string.upper)) end Responder = {} Responder.__index = Responder if(rx == nil) then rx = {} end function rx.errorWrapper(f, name, errType) errType = errType and (errType .. ' ') or '' return function(...) local p = {...} local ok, err = pcall(function() f(unpack(p)) end) if(not ok) then print(errType .. name .. ' ERR: ') print(err) end end end function Responder:new(functionToWrap) assert(self, "missing receiver") local r = setmetatable({}, self) r.func = functionToWrap r.co = coroutine.create(r.func) return r end function Responder:__call(...) if self:canResume() then local response = { coroutine.resume(self.co, ...) } table.remove(response, 1) if(type(response[1]) == 'function') then self.check = response[1] table.remove(response, 1) end return true, response else return false end end function Responder:finished() return coroutine.status(self.co) == "dead" end function Responder:canResume() if not self:finished() then if self.check then return self:check() else return true end end return false end EventTable = {} EventTable.__index = EventTable function EventTable:on(optsOrName, f) local name local opts = {} if type(optsOrName) == "table" then opts = optsOrName name = opts.event else name = optsOrName end assert(type(name) == "string" and name ~= "", "an event name must be supplied") if f then opts.f = f end assert(type(opts.f) == "function", "a handler must be supplied") opts.fWrapped = rx.errorWrapper(opts.f, name, 'EVENT') local responders = self[name] or {} table.insert(responders, opts) self[name] = responders return opts.f end function EventTable:off(name, responder) local responders = self[name] if responder and responders then local newResponders = {} for i=1,#responders do if responders[i].f ~= responder then table.insert(newResponders, responders[i]) end end self[name] = newResponders else self[name] = {} end end function EventTable:dispatch(name, ...) local responders = self[name] or {} local preservedResponders = {} local sent = false for i, responder in ipairs(responders) do if type(responder.filter) == "function" and not responder.filter(...) then table.insert(preservedResponders, responder) break end local f = Responder:new(responder.fWrapped) f(...) if not f:finished() then self:addResponder(f) end sent = true if not responder.once then table.insert(preservedResponders, responder) end end self[name] = preservedResponders return sent end function EventTable:addResponder(responder) table.insert(self._unfinishedResponders, responder) end function EventTable:resume() local newUnfinishedResponders = {} for _, responder in ipairs(self._unfinishedResponders) do responder() if not responder:finished() then table.insert(newUnfinishedResponders, responder) end end self._unfinishedResponders = newUnfinishedResponders end function EventTable:new() assert(self, "missing receiver") local et = setmetatable({}, self) et._unfinishedResponders = {} return et end local osEvents = EventTable:new() function on(...) return osEvents:on(...) end function off(...) return osEvents:off(...) end function add(func) local responder = Responder:new(rx.errorWrapper(func, 'add')) osEvents:addResponder(responder) end function queue(...) os.queueEvent(...) end function waitUntil(checkFunc) coroutine.yield(checkFunc) end function once(event, func, filter) if(type(event) == 'table') then local opts = event event = opts.event func = opts.f or opts.func filter = opts.filter end on { event = event, filter = filter, once = true, f = func } end function wait(seconds, cancelFunction) local ourID = os.startTimer(seconds) local fired = false cancelFunction = cancelFunction or function() return false end on { event = "timer", filter = function(timerID) return timerID == ourID or fired end, once = true, f = function() fired = true end } waitUntil(function() return fired or cancelFunction() end) os.cancelTimer(ourID) fired = true end function run(mainFunction) if mainFunction then ok, err = pcall(function() add(function() mainFunction() quit() end) end) if(not ok) then print('run err') print(err) end ok, err = pcall(function() osEvents:resume() end) if(not ok) then print('run err2') print(err) end end while true do local event = {os.pullEventRaw()} local eventName = event[1] local handled = osEvents:dispatch(unpack(event)) if not handled then if eventName == "terminate" then print("Shutting down") break end end osEvents:resume() end end function quit() queue('terminate') end if(positions == nil) then positions = {} end function positions.translate(from, diff) local result = {} diff = convert.toLocation(diff) result.x = from.x + diff.x result.y = from.y + diff.y result.z = from.z + diff.z return convert.toLocation(result) end if(network == nil) then network = {} end network.addr = {} network.senderID = os and os.getComputerID() or 0 network.protocol = "BIFORMATION.PLAIN.V2" function network.open(side) if(side ~= nil) then pcall(function() rednet.open(side) end) else local i = 1 while(not rednet.isOpen() and i <= #var.sides) do pcall(function() rednet.open(var.sides[i]) end) i = i + 1 end end local isOpen = rednet.isOpen() if(isOpen) then log.logVerbose("Connected to network") else log.logWarning("Failed to connect to network") end return isOpen end function network.receive(timeout, filter) if(not rednet.isOpen()) then network.open() end log.logVerbose("Listening on network") filter = filter or function() return true end local received = false local response = nil local receiver = function(sender, message, protocol) protocol = protocol or '_' log.logVerbose('Received message from #' .. sender .. ' protocol ' .. protocol) log.logVerbose(textutils.serialise(message)) response = {sender, message, protocol} received = true end on({ event = 'rednet_message', filter = function(sender, message, protocol) return protocol == network.protocol and filter(sender, message, protocol) end, once = true, f = receiver }) if(timeout ~= nil) then wait(timeout, function() return received end) if(not received) then off('rednet_message', receiver) end else waitUntil(function() return received end) end local senderId, message, protocol = unpack(response or {}) if(senderId ~= nil) then log.logVerbose("Received message from #" .. senderId) return message, senderId else log.logWarning("Received no message within " .. (timeout or -1) .. " seconds") return nil, nil end end function network.broadcast(message) method.expect(1, message, 'table') if(not rednet.isOpen()) then network.open() end message.type = message.type or 'REQUEST' message.headers = message.headers or {} message.headers.sender = network.senderID message.headers.corID = message.headers.corID or math.random(0, 9999) log.logVerbose("Broadcasting to network") return rednet.broadcast(message, network.protocol) end function network.send(message, receiver) method.expect(1, message, 'table') method.expect(2, receiver, 'number') if(not rednet.isOpen()) then network.open() end message.headers = message.headers or {} message.headers.sender = network.senderID message.headers.corID = message.headers.corID or math.random(0, 9999) log.logVerbose("Sending message via network to #" .. receiver) return rednet.send(receiver, message, network.protocol) end function network.addAddress(name, id) network.addr[name] = id end function network.respond(request, response) network.send({ type='RESPONSE', url = request.url, method = 'GET', headers = { request = request, corID = request.headers.corID }, body = response }, request.headers.sender) end function network.get(target, url, headers, body, timeout) if(type(target) == 'string') then target = network.addr[target] end local message = { type = 'REQUEST', method = 'GET', url = url, headers = headers or {}, body = body or {} } network.send(message, target) return network.receive(timeout or 60, function(sender, received, protocol) return received.type == 'RESPONSE' and received.headers.corID == message.headers.corID end) end if(method == nil) then method = {} end local native_select, native_type = select, type local function get_type_names(...) local types = table.pack(...) for i = types.n, 1, -1 do if types[i] == "nil" then table.remove(types, i) end end if #types <= 1 then return tostring(...) else return table.concat(types, ", ", 1, #types - 1) .. " or " .. types[#types] end end function method.expect(index, value, ...) local t = native_type(value) for i = 1, native_select("#", ...) do if t == native_select(i, ...) then return value end end local name local ok, info = pcall(debug.getinfo, 3, "nS") if ok and info.name and info.name ~= "" and info.what ~= "C" then name = info.name end local type_names = get_type_names(...) if name then error(("bad argument #%d to '%s' (expected %s, got %s)"):format(index, name, type_names, t), 3) else error(("bad argument #%d (expected %s, got %s)"):format(index, type_names, t), 3) end end if(log == nil) then log = {} end loglevel = settings.get('loglevel') or 3 function log.setLoglevel(level) if(type(level) == "string") then if(level == "error") then loglevel = 4 end if(level == "warning") then loglevel = 3 end if(level == "info") then loglevel = 2 end if(level == "verbose") then loglevel = 1 end settings.set("loglevel", loglevel) elseif(type(level) == "number") then loglevel = level settings.set("loglevel", level) end end function log.logError(text) if(loglevel <= 4) then print(text) end end function log.logWarning(text) if(loglevel <= 3) then print(text) end end function log.logInformation(text) if(loglevel <= 2) then print(text) end end function log.logInfo(...) return log.logInformation(...) end function log.logVerbose(text) if(loglevel <= 1) then print(text) end end if(linq == nil) then linq = {} end linq.__index = linq function linq:__pairs(t) return next, self:get(), nil end function linq:_new(data, func) assert(self, "missing something") local e = setmetatable({}, self) e.linqable = true if(data.linqable) then e.data = {} e.parent = data else e.data = data e.parent = nil end e.index = 1 if(func == nil) then e.co = Responder:new(function() for key, value in pairs(e.data) do coroutine.yield(false, key, value) end end) else e.co = Responder:new(func) end return e end function isEmpty(tbl) assert(type(tbl) == 'table', 'isEmpty expects table') local empty = true for _,_ in pairs(tbl) do empty = false break end return empty end function linq:where(o, f) local filter = function(key, value, func) if(func(key, value)) then coroutine.yield(false, key, value) end end return self:_filter('where', 'function', filter, o, f) end function linq:select(o, f) local filter = function(key, value, func) coroutine.yield(false, key, func(key, value)) end return self:_filter('select', 'function', filter, o, f) end function linq:skip(o, n) local filter = function(key, value, num, i) if(i > num) then coroutine.yield(false, key, value) end end return self:_filter('skip', 'number', filter, o, n) end function linq:take(o, n) local filter = function(key, value, num, i) if(i <= num) then coroutine.yield(false, key, value) end end return self:_filter('take', 'number', filter, o, n) end function linq:contains(o, s) return self:where(o, function(key, value) return s == value end):any() end function linq:join(obj, param) if(param ~= nil and not obj.linqable) then return linq:_new(obj):join(param) end assert(type(obj) == 'table', '.join should have converted obj to table') assert(param == nil, '.join param should be nil') param = obj obj = self return linq:_new(self, function() local i = 1 while(not obj.co:finished()) do local _,response = obj.co() if(obj.co:finished()) then break end if(isEmpty(response)) then print('.join response is empty!') break end local key = response[2] local value = response[3] coroutine.yield(false, i, value) i = i + 1 end for _, value in pairs(param) do coroutine.yield(false, i, value) i = i + 1 end end) end function linq:_filter(filterName, filterParamType, filterFunc, obj, param) if(type(obj) ~= filterParamType and not obj.linqable) then return linq:_new(obj):_filter(filterName, filterParamType, filterFunc, param) end assert(type(obj) == filterParamType, '.'.. filterName .. ' should have converted obj to ' .. filterParamType) assert(param == nil, '.'.. filterName .. ' param should be nil') param = obj obj = self return linq:_new(self, function() local i = 1 while(not obj.co:finished()) do local _,response = obj.co() if(obj.co:finished()) then break end if(isEmpty(response)) then print('.'.. filterName .. ' response is empty!') break end local key = response[2] local value = response[3] filterFunc(key, value, param, i) i = i + 1 end end) end function linq:get(obj) if(obj ~= nil and not obj.linqable) then return linq:_new(obj):get() end local data = {} while(not self.co:finished()) do local _,response = self.co() if(self.co:finished()) then break end if(isEmpty(response)) then print('.get response is empty!') break end local value = response[3] table.insert(data, value) end return data end function linq:first(obj) if(obj ~= nil and not obj.linqable) then return linq:_new(obj):first() end local value = nil while(not self.co:finished()) do local _,response = self.co() if(self.co:finished()) then break end if(isEmpty(response)) then print('.first response is empty!') break end value = response[3] break end return value end function linq:any(obj) return self:first(obj) ~= nil end if(convert == nil) then convert = {} end function convert.toJson(message) return textutils.serialise(message) end function convert.fromJson(message) if(type(message) == "table") then return message end if(type(message) == "string") then return textutils.unserialise(message) end return nil end function convert.isJson(message) local json = convert.fromJson(message) return json ~= nil, json end function convert.toLocation(loc, y, z) local location = {} if(loc == nil) then return location end if(type(loc) == "table") then location.x = tonumber(loc.x) or tonumber(loc[1]) or 0 location.y = tonumber(loc.y) or tonumber(loc[2]) or 0 location.z = tonumber(loc.z) or tonumber(loc[3]) or 0 else location.x = tonumber(loc) or 0 location.y = tonumber(y) or 0 location.z = tonumber(z) or 0 end location[1] = location.x location[2] = location.y location[3] = location.z return location end local lib = {} lib.binet = network if(console == nil) then console = {} end function console.choice_impl(text, choices, add_space) local results = {} for n = 1, #choices do local option = choices[n] if #option + (add_space and 1 or 0) > #text and option:sub(1, #text) == text then local result = option:sub(#text + 1) if add_space then table.insert(results, result .. " ") else table.insert(results, result) end end end return results end function console.read( _sReplaceChar, consoletory, _fnComplete, _sDefault, _nTimeout) if _sReplaceChar ~= nil and type( _sReplaceChar ) ~= "string" then error( "bad argument #1 (expected string, got " .. type( _sReplaceChar ) .. ")", 2 ) end if consoletory ~= nil and type( consoletory ) ~= "table" then error( "bad argument #2 (expected table, got " .. type( consoletory ) .. ")", 2 ) end if _fnComplete ~= nil and type( _fnComplete ) ~= "function" then error( "bad argument #3 (expected function, got " .. type( _fnComplete ) .. ")", 2 ) end if _sDefault ~= nil and type( _sDefault ) ~= "string" then error( "bad argument #4 (expected string, got " .. type( _sDefault ) .. ")", 2 ) end if _nTimeout ~= nil and type( _nTimeout ) ~= "number" then error( "bad argument #5 (expected number, got " .. type( _sDefault ) .. ")", 2 ) end term.setCursorBlink( true ) local sLine if type( _sDefault ) == "string" then sLine = _sDefault else sLine = "" end local nHistoryPos local nPos = #sLine if _sReplaceChar then _sReplaceChar = string.sub( _sReplaceChar, 1, 1 ) end local tCompletions local nCompletion local function recomplete() if _fnComplete and nPos == string.len(sLine) then tCompletions = _fnComplete( sLine ) if tCompletions and #tCompletions > 0 then nCompletion = 1 else nCompletion = nil end else tCompletions = nil nCompletion = nil end end local function uncomplete() tCompletions = nil nCompletion = nil end local w = term.getSize() local sx = term.getCursorPos() local function redraw( _bClear ) local nScroll = 0 if sx + nPos >= w then nScroll = (sx + nPos) - w end local cx, cy = term.getCursorPos() term.setCursorPos( sx, cy ) local sReplace = (_bClear and " ") or _sReplaceChar if sReplace then term.write( string.rep( sReplace, math.max( string.len(sLine) - nScroll, 0 ) ) ) else term.write( string.sub( sLine, nScroll + 1 ) ) end if nCompletion then local sCompletion = tCompletions[ nCompletion ] local oldText, oldBg if not _bClear then oldText = term.getTextColor() oldBg = term.getBackgroundColor() term.setTextColor( colors.white ) term.setBackgroundColor( colors.gray ) end if sReplace then term.write( string.rep( sReplace, string.len( sCompletion ) ) ) else term.write( sCompletion ) end if not _bClear then term.setTextColor( oldText ) term.setBackgroundColor( oldBg ) end end term.setCursorPos( sx + nPos - nScroll, cy ) end local function clear() redraw( true ) end recomplete() redraw() local function acceptCompletion() if nCompletion then clear() local sCompletion = tCompletions[ nCompletion ] sLine = sLine .. sCompletion nPos = string.len( sLine ) recomplete() redraw() end end local currentTimer = nil local sessionID = math.random(0, 1000) function _timer() if(_nTimeout ~= nil) then add(function() local ourID = math.random(0, 1000) currentTimer = ourID wait(_nTimeout, function() return currentTimer ~= ourID end) if(currentTimer == ourID) then queue('stopconsole', sessionID) end end) end end local charListener = on('char', function(char) clear() sLine = string.sub( sLine, 1, nPos ) .. char .. string.sub( sLine, nPos + 1 ) nPos = nPos + 1 recomplete() redraw() _timer() end) local pasteListener = on('paste', function(paste) clear() sLine = string.sub( sLine, 1, nPos ) .. paste .. string.sub( sLine, nPos + 1 ) nPos = nPos + string.len( paste ) recomplete() redraw() _timer() end) local keyListener = on('key', function(key) if key == keys.enter then if nCompletion then clear() uncomplete() redraw() end queue('stopconsole', sessionID) elseif key == keys.left then if nPos > 0 then clear() nPos = nPos - 1 recomplete() redraw() end elseif key == keys.right then if nPos < string.len(sLine) then clear() nPos = nPos + 1 recomplete() redraw() else acceptCompletion() end elseif key == keys.up or key == keys.down then if nCompletion then clear() if key == keys.up then nCompletion = nCompletion - 1 if nCompletion < 1 then nCompletion = #tCompletions end elseif key == keys.down then nCompletion = nCompletion + 1 if nCompletion > #tCompletions then nCompletion = 1 end end redraw() elseif consoletory then clear() if key == keys.up then if nHistoryPos == nil then if #consoletory > 0 then nHistoryPos = #consoletory end elseif nHistoryPos > 1 then nHistoryPos = nHistoryPos - 1 end else if nHistoryPos == #consoletory then nHistoryPos = nil elseif nHistoryPos ~= nil then nHistoryPos = nHistoryPos + 1 end end if nHistoryPos then sLine = consoletory[nHistoryPos] nPos = string.len( sLine ) else sLine = "" nPos = 0 end uncomplete() redraw() end elseif key == keys.backspace then if nPos > 0 then clear() sLine = string.sub( sLine, 1, nPos - 1 ) .. string.sub( sLine, nPos + 1 ) nPos = nPos - 1 recomplete() redraw() end elseif key == keys.home then if nPos > 0 then clear() nPos = 0 recomplete() redraw() end elseif key == keys.delete then if nPos < string.len(sLine) then clear() sLine = string.sub( sLine, 1, nPos ) .. string.sub( sLine, nPos + 2 ) recomplete() redraw() end elseif key == keys["end"] then if nPos < string.len(sLine ) then clear() nPos = string.len(sLine) recomplete() redraw() end elseif key == keys.tab then acceptCompletion() end _timer() end) local resizeListener = on('term_resize', function() w = term.getSize() redraw() _timer() end) local stopped = false local quitListener = on({ event = 'stopconsole', once = true, filter = function(eSessionID) return eSessionID == sessionID end, f = function() off('char', charListener) off('paste', pasteListener) off('key', keyListener) off('term_resize', resizeListener) stopped = true if nCompletion then clear() uncomplete() redraw() end end }) _timer() waitUntil(function() return stopped end) local cx, cy = term.getCursorPos() term.setCursorBlink( false ) if(sLine ~= "") then term.setCursorPos( w + 1, cy ) print() end return sLine end  log.setLoglevel('verbose') local quitCommands = { 'exit', 'quit', 'stop' } local commands = { 'clear', 'update', 'get pods', 'remove pods', 'get -h', 'get --help', } local actualCommands = {} for _, c in ipairs(linq:join(commands, quitCommands):get()) do local command = '' for _, part in pairs(string.split(c, ' ')) do command = command .. part if(not linq:contains(actualCommands, command)) then table.insert(actualCommands, command) end command = command .. ' ' end end function choice_complete(text, completion) if(#text == 0) then return {} end return console.choice_impl(text, completion or actualCommands, false) end function networkRequestAwait(reqFunc) local fired = false local response = false local quit = false add(function() response = reqFunc() fired = true end) add(function() while(not quit and not fired) do local qinput = console.read(nil, nil, function(text) choice_complete(text, quitCommands) end, nil, 1) or '' quit = quit or linq:contains(quitCommands, qinput) end end) waitUntil(function() return quit or fired end) quit = true if(response == false) then response = nil end return response end network.addAddress('pod1', 35) network.addAddress('cache', 26) run(function() local input = '' while(not linq:contains(quitCommands, input)) do input = console.read(nil, nil, choice_complete) log.logVerbose('You typed: ' .. input) if(input == 'clear') then term.clear() elseif(input == 'update') then log.logVerbose('Loading handheld.lua file from cache...') local response = networkRequestAwait(function() return network.get('cache', '/luacache') end) if(response ~= nil) then local responseFile = linq:where(response.body, function(k, v) return v.name == 'handheld.lua' end):first() if(responseFile == nil) then error('File from cache was nil') end log.logVerbose('Found handheld.lua file from cache') local file = fs.open( responseFile.name, "wb" ) file.write(responseFile.content) file.close() log.logWarning('Rebooting...') wait(5) os.reboot() else log.logVerbose('Cache server did not respond') end elseif(string.starts(input, 'get ')) then local iType = string.after(input, 'get ') if(string.starts(iType, 'pod')) then local response = networkRequestAwait(function() return network.get('pod1', '/pods') end) if(response ~= nil) then print('get response;') print(textutils.serialise(response or {})) end end else log.logWarning('That is not a valid command') end end end)
