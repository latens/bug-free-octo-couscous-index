 if(var == nil) then var = {} end var.sides = {"right", "left", "up", "down", "front", "back"} var.directions = {"north", "east", "south", "west"} function string.starts(String,Start) return string.sub(String,1,string.len(Start))==Start end function string.before(String,Start) return string.sub(String,1,string.len(Start)) end function string.after(String,Start) return string.sub(String,string.len(Start) + 1) end function string.split (inputstr, sep) if sep == nil then sep = "." end local t={} for str in string.gmatch(inputstr, "([^"..sep.."]+)") do table.insert(t, str) end return t end function string.trim(s) return (string.gsub(s, "^%s*(.-)%s*$", "%1")) end function string.join(params, glue) if(glue == nil) then glue = '.' end local paramString = nil if(params ~= nil and type(params) == 'table') then for k,v in pairs(params) do if(paramString == nil) then paramString = v else paramString = paramString .. glue .. v end end else paramString = params end return paramString end function firstToUpper(str) return (str:gsub("^%l", string.upper)) end Responder = {} Responder.__index = Responder if(rx == nil) then rx = {} end function rx.errorWrapper(f, name, errType) errType = errType and (errType .. ' ') or '' return function(...) local p = {...} local ok, err = pcall(function() f(unpack(p)) end) if(not ok) then print(errType .. name .. ' ERR: ') print(err) end end end function Responder:new(functionToWrap) assert(self, "missing receiver") local r = setmetatable({}, self) r.func = functionToWrap r.co = coroutine.create(r.func) return r end function Responder:__call(...) if self:canResume() then local response = { coroutine.resume(self.co, ...) } table.remove(response, 1) if(type(response[1]) == 'function') then self.check = response[1] table.remove(response, 1) end return true, response else return false end end function Responder:finished() return coroutine.status(self.co) == "dead" end function Responder:canResume() if not self:finished() then if self.check then return self:check() else return true end end return false end EventTable = {} EventTable.__index = EventTable function EventTable:on(optsOrName, f) local name local opts = {} if type(optsOrName) == "table" then opts = optsOrName name = opts.event else name = optsOrName end assert(type(name) == "string" and name ~= "", "an event name must be supplied") if f then opts.f = f end assert(type(opts.f) == "function", "a handler must be supplied") opts.fWrapped = rx.errorWrapper(opts.f, name, 'EVENT') local responders = self[name] or {} table.insert(responders, opts) self[name] = responders return opts.f end function EventTable:off(name, responder) local responders = self[name] if responder and responders then local newResponders = {} for i=1,#responders do if responders[i].f ~= responder then table.insert(newResponders, responders[i]) end end self[name] = newResponders else self[name] = {} end end function EventTable:dispatch(name, ...) local responders = self[name] or {} local preservedResponders = {} local sent = false for i, responder in ipairs(responders) do if type(responder.filter) == "function" and not responder.filter(...) then table.insert(preservedResponders, responder) break end local f = Responder:new(responder.fWrapped) f(...) if not f:finished() then self:addResponder(f) end sent = true if not responder.once then table.insert(preservedResponders, responder) end end self[name] = preservedResponders return sent end function EventTable:addResponder(responder) table.insert(self._unfinishedResponders, responder) end function EventTable:resume() local newUnfinishedResponders = {} for _, responder in ipairs(self._unfinishedResponders) do responder() if not responder:finished() then table.insert(newUnfinishedResponders, responder) end end self._unfinishedResponders = newUnfinishedResponders end function EventTable:new() assert(self, "missing receiver") local et = setmetatable({}, self) et._unfinishedResponders = {} return et end local osEvents = EventTable:new() function on(...) return osEvents:on(...) end function off(...) return osEvents:off(...) end function add(func) local responder = Responder:new(rx.errorWrapper(func, 'add')) osEvents:addResponder(responder) end function queue(...) os.queueEvent(...) end function waitUntil(checkFunc) coroutine.yield(checkFunc) end function once(event, func, filter) if(type(event) == 'table') then local opts = event event = opts.event func = opts.f or opts.func filter = opts.filter end on { event = event, filter = filter, once = true, f = func } end function wait(seconds, cancelFunction) local ourID = os.startTimer(seconds) local fired = false cancelFunction = cancelFunction or function() return false end on { event = "timer", filter = function(timerID) return timerID == ourID or fired end, once = true, f = function() fired = true end } waitUntil(function() return fired or cancelFunction() end) os.cancelTimer(ourID) fired = true end function run(mainFunction) if mainFunction then ok, err = pcall(function() add(function() mainFunction() quit() end) end) if(not ok) then print('run err') print(err) end ok, err = pcall(function() osEvents:resume() end) if(not ok) then print('run err2') print(err) end end while true do local event = {os.pullEventRaw()} local eventName = event[1] local handled = osEvents:dispatch(unpack(event)) if not handled then if eventName == "terminate" then print("Shutting down") break end end osEvents:resume() end end function quit() queue('terminate') end if(positions == nil) then positions = {} end function positions.translate(from, diff) local result = {} diff = convert.toLocation(diff) result.x = from.x + diff.x result.y = from.y + diff.y result.z = from.z + diff.z return convert.toLocation(result) end if(network == nil) then network = {} end network.addr = {} network.senderID = os and os.getComputerID() or 0 network.protocol = "BIFORMATION.PLAIN.V2" function network.open(side) if(side ~= nil) then pcall(function() rednet.open(side) end) else local i = 1 while(not rednet.isOpen() and i <= #var.sides) do pcall(function() rednet.open(var.sides[i]) end) i = i + 1 end end local isOpen = rednet.isOpen() if(isOpen) then log.logVerbose("Connected to network") else log.logWarning("Failed to connect to network") end return isOpen end function network.receive(timeout, filter) if(not rednet.isOpen()) then network.open() end log.logVerbose("Listening on network") filter = filter or function() return true end local received = false local response = nil local receiver = function(sender, message, protocol) protocol = protocol or '_' log.logVerbose('Received message from #' .. sender .. ' protocol ' .. protocol) log.logVerbose(textutils.serialise(message)) response = {sender, message, protocol} received = true end on({ event = 'rednet_message', filter = function(sender, message, protocol) return protocol == network.protocol and filter(sender, message, protocol) end, once = true, f = receiver }) if(timeout ~= nil) then wait(timeout, function() return received end) if(not received) then off('rednet_message', receiver) end else waitUntil(function() return received end) end local senderId, message, protocol = unpack(response or {}) if(senderId ~= nil) then log.logVerbose("Received message from #" .. senderId) return message, senderId else log.logWarning("Received no message within " .. (timeout or -1) .. " seconds") return nil, nil end end function network.broadcast(message) method.expect(1, message, 'table') if(not rednet.isOpen()) then network.open() end message.type = message.type or 'REQUEST' message.headers = message.headers or {} message.headers.sender = network.senderID message.headers.corID = message.headers.corID or math.random(0, 9999) log.logVerbose("Broadcasting to network") return rednet.broadcast(message, network.protocol) end function network.send(message, receiver) method.expect(1, message, 'table') method.expect(2, receiver, 'number') if(not rednet.isOpen()) then network.open() end message.headers = message.headers or {} message.headers.sender = network.senderID message.headers.corID = message.headers.corID or math.random(0, 9999) log.logVerbose("Sending message via network to #" .. receiver) return rednet.send(receiver, message, network.protocol) end function network.addAddress(name, id) network.addr[name] = id end function network.respond(request, response) network.send({ type='RESPONSE', url = request.url, method = 'GET', headers = { request = request, corID = request.headers.corID }, body = response }, request.headers.sender) end function network.get(target, url, headers, body, timeout) if(type(target) == 'string') then target = network.addr[target] end local message = { type = 'REQUEST', method = 'GET', url = url, headers = headers or {}, body = body or {} } network.send(message, target) return network.receive(timeout or 60, function(sender, received, protocol) return received.type == 'RESPONSE' and received.headers.corID == message.headers.corID end) end if(method == nil) then method = {} end local native_select, native_type = select, type local function get_type_names(...) local types = table.pack(...) for i = types.n, 1, -1 do if types[i] == "nil" then table.remove(types, i) end end if #types <= 1 then return tostring(...) else return table.concat(types, ", ", 1, #types - 1) .. " or " .. types[#types] end end function method.expect(index, value, ...) local t = native_type(value) for i = 1, native_select("#", ...) do if t == native_select(i, ...) then return value end end local name local ok, info = pcall(debug.getinfo, 3, "nS") if ok and info.name and info.name ~= "" and info.what ~= "C" then name = info.name end local type_names = get_type_names(...) if name then error(("bad argument #%d to '%s' (expected %s, got %s)"):format(index, name, type_names, t), 3) else error(("bad argument #%d (expected %s, got %s)"):format(index, type_names, t), 3) end end if(log == nil) then log = {} end loglevel = settings.get('loglevel') or 3 function log.setLoglevel(level) if(type(level) == "string") then if(level == "error") then loglevel = 4 end if(level == "warning") then loglevel = 3 end if(level == "info") then loglevel = 2 end if(level == "verbose") then loglevel = 1 end settings.set("loglevel", loglevel) elseif(type(level) == "number") then loglevel = level settings.set("loglevel", level) end end function log.logError(text) if(loglevel <= 4) then print(text) end end function log.logWarning(text) if(loglevel <= 3) then print(text) end end function log.logInformation(text) if(loglevel <= 2) then print(text) end end function log.logInfo(...) return log.logInformation(...) end function log.logVerbose(text) if(loglevel <= 1) then print(text) end end if(linq == nil) then linq = {} end linq.__index = linq function linq:__pairs(t) return next, self:get(), nil end function linq:_new(data, func) assert(self, "missing something") local e = setmetatable({}, self) e.linqable = true if(data.linqable) then e.data = {} e.parent = data else e.data = data e.parent = nil end e.index = 1 if(func == nil) then e.co = Responder:new(function() for key, value in pairs(e.data) do coroutine.yield(false, key, value) end end) else e.co = Responder:new(func) end return e end function isEmpty(tbl) assert(type(tbl) == 'table', 'isEmpty expects table') local empty = true for _,_ in pairs(tbl) do empty = false break end return empty end function linq:where(o, f) local filter = function(key, value, func) if(func(key, value)) then coroutine.yield(false, key, value) end end return self:_filter('where', 'function', filter, o, f) end function linq:select(o, f) local filter = function(key, value, func) coroutine.yield(false, key, func(key, value)) end return self:_filter('select', 'function', filter, o, f) end function linq:skip(o, n) local filter = function(key, value, num, i) if(i > num) then coroutine.yield(false, key, value) end end return self:_filter('skip', 'number', filter, o, n) end function linq:take(o, n) local filter = function(key, value, num, i) if(i <= num) then coroutine.yield(false, key, value) end end return self:_filter('take', 'number', filter, o, n) end function linq:contains(o, s) return self:where(o, function(key, value) return s == value end):any() end function linq:join(obj, param) if(param ~= nil and not obj.linqable) then return linq:_new(obj):join(param) end assert(type(obj) == 'table', '.join should have converted obj to table') assert(param == nil, '.join param should be nil') param = obj obj = self return linq:_new(self, function() local i = 1 while(not obj.co:finished()) do local _,response = obj.co() if(obj.co:finished()) then break end if(isEmpty(response)) then print('.join response is empty!') break end local key = response[2] local value = response[3] coroutine.yield(false, i, value) i = i + 1 end for _, value in pairs(param) do coroutine.yield(false, i, value) i = i + 1 end end) end function linq:_filter(filterName, filterParamType, filterFunc, obj, param) if(type(obj) ~= filterParamType and not obj.linqable) then return linq:_new(obj):_filter(filterName, filterParamType, filterFunc, param) end assert(type(obj) == filterParamType, '.'.. filterName .. ' should have converted obj to ' .. filterParamType) assert(param == nil, '.'.. filterName .. ' param should be nil') param = obj obj = self return linq:_new(self, function() local i = 1 while(not obj.co:finished()) do local _,response = obj.co() if(obj.co:finished()) then break end if(isEmpty(response)) then print('.'.. filterName .. ' response is empty!') break end local key = response[2] local value = response[3] filterFunc(key, value, param, i) i = i + 1 end end) end function linq:get(obj) if(obj ~= nil and not obj.linqable) then return linq:_new(obj):get() end local data = {} while(not self.co:finished()) do local _,response = self.co() if(self.co:finished()) then break end if(isEmpty(response)) then print('.get response is empty!') break end local value = response[3] table.insert(data, value) end return data end function linq:first(obj) if(obj ~= nil and not obj.linqable) then return linq:_new(obj):first() end local value = nil while(not self.co:finished()) do local _,response = self.co() if(self.co:finished()) then break end if(isEmpty(response)) then print('.first response is empty!') break end value = response[3] break end return value end function linq:any(obj) return self:first(obj) ~= nil end if(convert == nil) then convert = {} end function convert.toJson(message) return textutils.serialise(message) end function convert.fromJson(message) if(type(message) == "table") then return message end if(type(message) == "string") then return textutils.unserialise(message) end return nil end function convert.isJson(message) local json = convert.fromJson(message) return json ~= nil, json end function convert.toLocation(loc, y, z) local location = {} if(loc == nil) then return location end if(type(loc) == "table") then location.x = tonumber(loc.x) or tonumber(loc[1]) or 0 location.y = tonumber(loc.y) or tonumber(loc[2]) or 0 location.z = tonumber(loc.z) or tonumber(loc[3]) or 0 else location.x = tonumber(loc) or 0 location.y = tonumber(y) or 0 location.z = tonumber(z) or 0 end location[1] = location.x location[2] = location.y location[3] = location.z return location end local lib = {} lib.binet = network  
