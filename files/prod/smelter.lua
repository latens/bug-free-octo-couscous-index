local _builddate = '2024-11-25 21:04:56';print(_builddate)
         Responder={}Responder.__index=Responder if(Responder==nil)then Responder={}end function Responder:new(functionToWrap)assert(self,"missing receiver")local r=setmetatable({},self)r.func=functionToWrap r.co=coroutine.create(r.func)if(r.co==nil)then error('Could not create new responder')end return r end function Responder:__call(...)if self:canResume()then local response={coroutine.resume(self.co,...)}if(not response[1])then print('ERR: in Responder:__call')print(response[2])end table.remove(response,1)if(type(response[1])=='function')then self.check=response[1] table.remove(response,1)else self.check=nil end return true,response else return false end end function Responder:stop()self.co=nil end function Responder:finished()return self.co==nil or coroutine.status(self.co)=="dead" end function Responder:canResume()if not self:finished()then if self.check then return self:check()else return true end end return false end if(class==nil)then class={}end class=function(classDef,parentClass)if classDef.super or classDef.new or classDef.is then error("super and new can not exist within class defenitions",2)end if parentClass then setmetatable(classDef,{__index=parentClass})classDef.super=parentClass end function classDef:new(...)local new={}setmetatable(new,{__index=self})if new.constructor then new:constructor(...)end return new end function classDef:is(c)local selfTable=getmetatable(self)local cTable=getmetatable(c)return(selfTable~=nil and c==selfTable.__index)or(cTable~=nil and self==cTable.__index)end return classDef end if(convert==nil)then convert={}end function convert.toJson(message)return textutils.serialise(message)end function convert.fromJson(message)if(type(message)=="table")then return message end if(type(message)=="string")then return textutils.unserialise(message)end return nil end function convert.isJson(message)local json=convert.fromJson(message)return json~=nil,json end function convert.toLocation(loc,y,z)local location={}if(loc==nil)then return location end if(type(loc)=="table")then location.x=tonumber(loc.x)or tonumber(loc[1])or 0 location.y=tonumber(loc.y)or tonumber(loc[2])or 0 location.z=tonumber(loc.z)or tonumber(loc[3])or 0 else location.x=tonumber(loc)or 0 location.y=tonumber(y)or 0 location.z=tonumber(z)or 0 end location[1]=location.x location[2]=location.y location[3]=location.z return location end if(files==nil)then files={}end function files.write(name,content)local file=fs.open(name,"wb")file.write(content)file.close()end function files.read(name)if(not fs.exists(name))then return nil end local file=fs.open(name,"r")local contents=file.readAll()file.close()return contents end function files.writeJson(name,content)return files.write(name,textutils.serialiseJSON(content))end function files.readJson(name)local content=files.read(name)return content and textutils.unserialiseJSON(content)or nil end if(method==nil)then method={}end local native_select,native_type=select,type local function get_type_names(...)local types=table.pack(...)for i=types.n,1,-1 do if types[i]=="nil" then table.remove(types,i)end end if #types<=1 then return tostring(...)else return table.concat(types,",",1,#types-1).." or "..types[#types] end end function method.expect(index,value,...)local t=native_type(value)for i=1,native_select("#",...)do if t==native_select(i,...)then return value end end local name local ok,info=pcall(debug.getinfo,3,"nS")if ok and info.name and info.name~="" and info.what~="C" then name=info.name end local type_names=get_type_names(...)if name then error(("bad argument #%d to '%s'(expected %s,got %s)"):format(index,name,type_names,t),3)else error(("bad argument #%d(expected %s,got %s)"):format(index,type_names,t),3)end end if(var==nil)then var={}end var.sides={"right","left","up","bottom","front","back"}var.directions={"north","east","south","west"}var.isOldMinecraft=_HOST:match('Minecraft 1.12')if(try==nil)then try={}end try=setmetatable(try,{__call=function(self,func,...)local result={pcall(func,...)}if(table.remove(result,1))then return unpack(result)else print('ERR','try()',result[1])end end})function try.catch(startFunc,catchFunc)local result={pcall(startFunc)}if(table.remove(result,1))then return unpack(result)else catchFunc(result[1])end end function string.starts(String,Start)return string.sub(String,1,string.len(Start))==Start end function string.before(String,Start)return string.sub(String,1,string.len(Start))end function string.after(String,Start)return string.sub(String,string.len(Start)+1)end function string.split(inputstr,sep)if sep==nil then sep="." end local t={}for str in string.gmatch(inputstr,"([^"..sep.."]+)")do table.insert(t,str)end return t end function string.trim(s)return(string.gsub(s,"^%s*(.-)%s*$","%1"))end function string.join(params,glue)if(#params==1)then return tostring(params[1])end glue=glue or '.' local t={}for k,v in ipairs(params)do t[#t+1]=tostring(v)end return table.concat(t,glue)end function firstToUpper(str)return(str:gsub("^%l",string.upper))end function extract(tbl,...)local toIterate={...}local result={}for k,name in ipairs(toIterate)do result[k]=tbl[name] or nil end return unpack(result,1,#toIterate)end if(linq==nil)then linq={}end if(_linq==nil)then _linq={}end function _linq._iterator(self,iteratorfunc)for i,keyvalue in ipairs(self.cache)do coroutine.yield(keyvalue[1],keyvalue[2],i)end local i=#self.cache+1 if(not self.done and self.parent~=nil)then local pIterator=self.parent.getIterator()local pDone,pKey,pValue=pIterator()while(not pDone and pKey~=nil and not self.done)do if(self.filter==nil or self.filter(pKey,pValue,i,self))then if(iteratorfunc)then pKey,pValue=iteratorfunc(pKey,pValue,i,self)end self.cache[i]={pKey,pValue}coroutine.yield(pKey,pValue,i)i=i+1 end pDone,pKey,pValue=pIterator()end end if(not self.done and self.data)then for k,v in pairs(self.data)do if(not self.done and self.filter==nil or self.filter(k,v,i,self))then if(iteratorfunc)then k,v=iteratorfunc(k,v,i,self)end self.cache[i]={k,v}coroutine.yield(k,v,i)i=i+1 end end end end function _linq._wrap(func)local co=Responder:new(func)return function(...)_,response=co()if(not co:canResume())then return true end if(type(response)~='table')then error('expected table')end response=response or{}return false,response[1],response[2] end end linq=class({constructor=function(self,params)self.new=nil self.isLinq=true local data,filter,iterator,parent=params.data,params.filter,params.iterator,params.parent self.getIterator=function()return _linq._wrap(function()if(iterator)then iterator(self)else _linq._iterator(self)end self.done=true end)end if(type(filter)=='string' or type(filter)=='number')then filter=function(k,v)return v==filter end end self.filter=filter self.cache={}self.data=data self.parent=parent end,cache=nil,data=nil,done=false,filter=nil,parent=nil,isLinq=false,newSubQuery=function(self,params)params.parent=self return linq:new(params)end})function linq:where(data,func)if(func~=nil)then return linq:new({data=data,filter=func})else func=data return self:newSubQuery({filter=func})end end function linq:take(data,count)if(count~=nil)then return linq:new({data=data,filter=function(k,v,i,self)self.done=i==count return k<=count end})else count=data return self:newSubQuery({filter=function(k,v,i,self)self.done=i==count return i<=count end})end end function linq:skip(data,count)if(count~=nil)then count=count+1 return linq:new({data=data,filter=function(k,v,i)count=count-1 return k>count end})else count=data+1 return self:newSubQuery({filter=function(k,v,i)count=count-1 return k>count end})end end function linq:join(dataA,dataB)if(dataB==nil)then dataA,dataB=self,dataA if(not dataA.isLinq)then error('linq:join expected two arguments')end end if(dataA.isLinq)then if(dataB.isLinq)then return linq:new({iterator=function()_linq._iterator(dataA)_linq._iterator(dataB)end})else return self:newSubQuery({data=dataB})end else return linq:new({parent=linq:new({data=dataA}),data=dataB})end end function linq:reverse()local oldSelf=self return linq:new({iterator=function(self)self.data={}local tempData={}oldSelf:each(function(k,v)table.insert(tempData,{k,v})end)local y=1 for i=#tempData,1,-1 do self.data[y]=tempData[i] y=y+1 end tempData=nil _linq._iterator(self,function(key,value)return value[1],value[2] end)end})end function linq:getSorted(data,func)if(data==nil)then return linq:getSorted(self:get())elseif(func==nil)then table.sort(data)return data elseif(type(func)=='function')then table.sort(data,func)return data else print('linq:sort','unknown arguments',data,func)end end function linq:get()local data={}local iterator=self.getIterator()local pDone,pKey,pValue=iterator()while(not pDone)do table.insert(data,pValue)pDone,pKey,pValue=iterator()end return data end function linq:first(data)if(data==nil)then local iterator=self.getIterator()local pDone,pKey,pValue=iterator()return not pDone and pValue else for k,v in pairs(data)do return v end end end function linq:last()local iterator=self.getIterator()local pDone,pKey,pValue=iterator()local last=pValue while(not pDone)do last=pValue pDone,pKey,pValue=iterator()end return last end function linq:_cache()local iterator=self.getIterator()while(not iterator())do end end function linq:any(data,funcOrData)if(data==nil)then local iterator=self.getIterator()local pDone=iterator()return not pDone elseif(type(funcOrData)=='function')then for k,v in pairs(data)do if(funcOrData(k,v))then return true end end return false elseif(funcOrData~=nil)then for k,v in pairs(data)do if(v==funcOrData)then return true end end return false elseif(type(data)=='table')then for k,v in pairs(data)do return true end return false else return self:where(data):any()end end linq.contains=linq.any function linq:each(data,func)if(func==nil)then func=data return self:newSubQuery({iterator=function(self)_linq._iterator(self,func)end}):get()else return linq:new({data=data,iterator=function(self)_linq._iterator(self,func)end}):get()end end function linq:select(data,func)if(func==nil)then func=data return self:newSubQuery({iterator=function(self)_linq._iterator(self,function(k,v)return k,func(k,v)end)end})else return linq:new({data=data,iterator=function(self)_linq._iterator(self,function(k,v)return k,func(k,v)end)end})end end linq.map=linq.select function linq:remove()local function getData(linqItem)if(linqItem.parent~=nil)then return getData(linqItem.parent)end return linqItem.data end local data=getData(self)self:reverse():each(function(k,v)table.remove(data,k)end)end function linq:indexOf(data,obj)if(obj==nil)then obj=data return self:where(function(k,v)return v==obj end):select(function(k)return k end):first()else return linq:new({data=data}):indexOf(obj)end end if(log==nil)then log={}end loglevel=settings.get('loglevel')or 3 function log.setLoglevel(level)if(type(level)=="string")then if(level=="error")then loglevel=4 end if(level=="warning")then loglevel=3 end if(level=="info" or level=="information")then loglevel=2 end if(level=="verbose")then loglevel=1 end settings.set("loglevel",loglevel)elseif(type(level)=="number")then loglevel=level settings.set("loglevel",level)end end function log._log(filter,...)if(loglevel<=filter)then print(string.join({...},''))return true else return false end end function log.logError(...)return log._log(4,...)end function log.logWarning(...)return log._log(3,...)end function log.logInformation(...)return log._log(2,...)end function log.logVerbose(...)return log._log(1,...)end function log.bool(boolean)return boolean and 'true' or 'false' end log.logInfo=log.logInformation if(tables==nil)then tables={}end function tables.removeMany(t,fnRemove)if(fnRemove==nil)then return t end local typ=type(fnRemove)local j,n=1,#t if(typ=='function')then for i=1,n do if(fnRemove(t,i,j))then t[i]=nil; else if(i~=j)then t[j]=t[i]; t[i]=nil; end j=j+1; end end else for i=1,n do if(t[i]==fnRemove)then t[i]=nil; else if(i~=j)then t[j]=t[i]; t[i]=nil; end j=j+1; end end end if(#t>j)then n=#t for i=j,n do if(t[i]~=nil)then if(i~=j)then t[j]=t[i]; t[i]=nil; end j=j+1; end end end return t; end function tables.iShallowCopy(t)if(#t==0)then return t end local t2={}for k,v in ipairs(t)do t2[k]=v end return t2 end function tables.deepCopy(t)local t2={}for k,v in pairs(t)do if(type(v)=='table')then t2[k]=tables.deepCopy(v)else t2[k]=v end end return t2 end function tables.immutableInsert(t,item,index)index=index or(#t+1)local newT=tables.iShallowCopy(t)table.insert(newT,index,item)return newT end function tables.sortBy(t,property,...)if(...==nil)then table.sort(t,function(a,b)return a[property]<b[property] end)else local properties={property,...}table.sort(t,function(a,b)for i=1,#properties do if(a[properties[i]]<b[properties[i]])then return true end if(a[properties[i]]>b[properties[i]])then return false end end end)end return t end function tables.sortByDescending(t,property,...)if(...==nil)then table.sort(t,function(a,b)return a[property]>b[property] end)else local properties={property,...}table.sort(t,function(a,b)for i=1,#properties do if(a[properties[i]]>b[properties[i]])then return true end if(a[properties[i]]<b[properties[i]])then return false end end end)end return t end tables.sortByAscending=tables.sortBy if(generic_inventory==nil)then generic_inventory={}end local generic_inventory_meta={__index={foreach=function(self,func)for slot,item in pairs(self)do if(item and item.count>0)then func(slot,item)end end end,where=function(self,func)for slot,item in pairs(self)do if(item and item.count>0 and func(slot,item))then return slot,item end end end}}function generic_inventory.init(inventory)return setmetatable(inventory,generic_inventory_meta)end function generic_inventory.get_compact_moves(inventory,fast)local groups={}local sizeLimit=64 local totalCount={}local moves={}inventory:foreach(function(slot,item)if(not groups[item.name])then groups[item.name]={}totalCount[item.name]=0 end if(item.count<sizeLimit)then table.insert(groups[item.name],{slot,item.count})totalCount[item.name]=totalCount[item.name]+item.count end end)for name,tuples in pairs(groups)do local bins=#tuples-math.ceil(totalCount[name] / sizeLimit)tables.sortByDescending(tuples,2)for a=1,#tuples do for b=a+1,#tuples do if(tuples[a][2]+tuples[b][2]<=sizeLimit)then table.insert(moves,{tuples[a][1],tuples[b][1]})tuples[b][2]=tuples[b][2]+tuples[a][2] tuples[a][2]=0 break end end if(tuples[a][2]==0)then bins=bins-1 end end if(bins>0 and not fast)then tables.sortByDescending(tuples,2)for a=1,#tuples do if(bins>0 and tuples[a][2]<sizeLimit)then for b=a+1,#tuples do local toTransfer=math.min(sizeLimit-tuples[b][2],tuples[a][2])table.insert(moves,{tuples[a][1],tuples[b][1]})tuples[b][2]=tuples[b][2]+toTransfer tuples[a][2]=tuples[a][2]-toTransfer if(tuples[a][2]==0)then bins=bins-1 break end end end end end end return moves end if(rx==nil)then rx={}end function rx.errorWrapper(f,name,errType)return function(...)local ok,err=pcall(f,...)if(not ok)then print('ERR:',errType or '',name or '')print(err)end end end EventTable={}EventTable.__index=EventTable function EventTable:on(optsOrName,f,filter)local opts if type(optsOrName)=="table" then opts=optsOrName else opts={event=optsOrName,f=f,filter=filter}end local name=opts.event assert(type(name)=="string" and name~="",":on requires an event name")assert(type(opts.f)=="function",":on requires an event handler")if(opts.handler)then opts.fWrapped=opts.handler else opts.fWrapped=rx.errorWrapper(opts.f,name,'EVENT')end self[name]=self[name] or{}table.insert(self[name],opts)return opts.f end function EventTable:off(name,responder)if(name==nil)then return end if responder and self[name] then tables.removeMany(self[name],function(t,i)return t[i].f==responder end)elseif(type(name)=='string')then self[name]=nil elseif(type(name)=='function')then if(self['timer'])then tables.removeMany(self['timer'],function(t,i)return t[i].f==name end)end tables.removeMany(self._unfinishedResponders,function(t,i)return t[i].func==name end)end end function EventTable:dispatch(name,...)if(self[name]==nil or #self[name]==0)then return false end local sent=false local args={...}tables.removeMany(self[name],function(t,i)local responder=t[i] if type(responder.filter)=="function" and not responder.filter(table.unpack(args))then return false else local f,ok,fResult if(responder.handler)then f=responder.handler ok,fResult=f(name,table.unpack(args))else f=Responder:new(responder.fWrapped)ok,fResult=f(table.unpack(args))end sent=true if not f:finished()then if(type(fResult)=='table' and type(fResult[1])=='string')then local event,filter=fResult[1],fResult[2] if(responder.handler and name==event)then responder.filter=type(filter)=='function' and filter return false else self:on({event=event,handler=f,f=responder.f,filter=type(filter)=='function' and filter,once=false})end else self:addResponder(f)end end return responder.handler~=nil or responder.once end end)return sent end function EventTable:addResponder(responder)table.insert(self._unfinishedResponders,responder)end function EventTable:resume()local newUnfinishedResponders={}for _,responder in ipairs(self._unfinishedResponders)do local ok,fResult=responder()if not responder:finished()then if(ok and type(fResult[1])=='string')then self:on({event=fResult[1],handler=responder,f=responder.func,filter=type(fResult[2])=='function' and fResult[2],once=false})else table.insert(newUnfinishedResponders,responder)end end end self._unfinishedResponders=newUnfinishedResponders end function EventTable:new()assert(self,"missing receiver")local et=setmetatable({},self)et._unfinishedResponders={}return et end local osEvents=EventTable:new()function on(...)return osEvents:on(...)end function off(...)return osEvents:off(...)end function add(func)local responder=Responder:new(rx.errorWrapper(func,'add'))osEvents:addResponder(responder)return responder.func end function queue(...)os.queueEvent(...)end function waitUntil(checkFunc)if(not checkFunc())then coroutine.yield(checkFunc)end end function once(event,func,filter)if(type(event)=='table')then local opts=event event=opts.event func=opts.f or opts.func filter=opts.filter end return on{event=event,filter=filter,once=true,f=func}end function wait(seconds,cancelFunction)local ourID=os.startTimer(seconds)if(cancelFunction~=nil)then local fired=false local onListener=on{event="timer",filter=function(timerID)return timerID==ourID or fired end,once=true,f=function()fired=true end}waitUntil(function()return fired or cancelFunction()end)off('timer',onListener)os.cancelTimer(ourID)else coroutine.yield('timer',function(id)return id==ourID end)end end function waitForEvent(event,filter)return coroutine.yield(event,filter)end rx.debouncers={}function prebounce(name,func)if(rx.debouncers[name] or type(func)~='function')then return end rx.debouncers[name]={on=add(function()rx.debouncers[name]=nil end)}return func()end function debounce(name,func,timeout)rx.debouncers[name]=rx.debouncers[name] or{}local db=rx.debouncers[name] if(timeout)then if(db.id)then os.cancelTimer(db.id)off('timer',db.on)end db.id=os.startTimer(timeout)db.on=on{event="timer",filter=function(timerID)return timerID==db.id end,once=true,f=function()rx.debouncers[name]=nil func()end}else if(db.on)then off(db.on)end db.on=add(function()rx.debouncers[name]=nil func()end)end end function run(mainFunction)mainFunction=mainFunction or function()while(true)do wait(10)end end if mainFunction then ok,err=pcall(add,function()mainFunction()quit()end)if(not ok)then print('run err')print(err)end ok,err=pcall(osEvents.resume,osEvents)if(not ok)then print('run err2')print(err)end end while true do local event={os.pullEventRaw()}local eventName=event[1] local handled=osEvents:dispatch(unpack(event))if not handled then if eventName=="terminate" then print("Shutting down")break end end osEvents:resume()end end function quit()queue('terminate')end if(parallel==nil)then parallel={}end parallel.waitForAll=function(tbl,...)local funcs=type(tbl)=='table' and tbl or{tbl,...}local todo=#funcs for k,func in ipairs(funcs)do add(function()func()todo=todo-1 end)end waitUntil(function()return todo==0 end)end parallel.waitForAny=function(tbl,...)local funcs=type(tbl)=='table' and tbl or{tbl,...}local todo=1 local handlers={}for k,func in ipairs(funcs)do handlers[k]=add(function()func()todo=todo-1 end)end waitUntil(function()return todo==0 end)for k,v in ipairs(handlers)do off(v)end end parallel._meta={__index={new=function(self)for i=#self,1,-1 do self[i]=nil end return self end,add=table.insert,run=parallel.waitForAll,waitForAll=parallel.waitForAll,waitForAny=parallel.waitForAny}}parallel._meta.__index.clear=parallel._meta.__index.new parallel.new=function()return setmetatable({},parallel._meta)end if(network==nil)then network={}end network.addr={}network.senderID=os and os.getComputerID()or 0 network.protocol="BIFORMATION.PLAIN.V2" network.queueUpdates=true network.hasModem=peripheral.find('modem',function(name,wrapped)return wrapped.isWireless()end)~=nil add(function()on({event='peripheral',filter=function(side)return peripheral.hasType(side,'modem')and not peripheral.hasType(side,'peripheral_hub')end,once=false,f=function(side)network.hasModem=true network.open(side)end})on({event='peripheral_detach',once=false,f=function()network.hasModem=false for k,modem in ipairs({peripheral.find('modem')})do network.hasModem=modem.isWireless()if(network.hasModem)then network.open()break end end end})end)rednet.CHANNEL_BROADCAST=51932 local cAddress=class({constructor=function(self,name,id)self.name=name self.id=id self.dropped=0 end})function network.getIds(name)return network.hasAddress(name)and linq:select(network.addr[name].points,function(key,value)return value.id end):get()or{}end function network.getAddresses(name)if(name)then return network.addr[name]~=nil and network.addr[name].points else return network.addr end end function network.getTypes()local types={}for typ,adr in pairs(network.addr)do table.insert(types,typ)end return types end function network.hasAddress(name)return network.addr[name]~=nil and linq:any(network.addr[name].points)end function network.printAddresses(name)for typ,adr in pairs(network.addr)do if(not name or typ==name)then log.logInformation(typ,':',string.join(linq:select(adr.points,function(key,value)return value.id end):getSorted(),','))end end end function network.getCurrentAddress(name)if(not network.hasAddress(name))then return nil end local address=network.addr[name] address.pointer=((address.pointer-1)% #address.points)+1 return address.points[address.pointer] end function network.getAddress(name)if(not network.hasAddress(name))then return nil end network.addr[name].pointer=(network.addr[name].pointer % #network.addr[name].points)+1 return network.getCurrentAddress(name)end function network.addAddress(name,id)if(not network.hasAddress(name))then network.addr[name]={points={},pointer=0}end if(not linq:where(network.addr[name].points,function(k,v)return v.id==id end):any())then table.insert(network.addr[name].points,cAddress:new(name,id))if(network.queueUpdates)then queue('network_address_added',{name=name,id=id})end end end function network.removeAddress(name,id)if(not network.hasAddress(name))then return nil end linq:where(network.addr[name].points,function(k,v)return v.id==id end):take(1):remove()if(network.queueUpdates)then queue('network_address_removed',{name=name,id=id,anyLeft=network.hasAddress(name)})end end function network.clearAddress(name)if(not network.hasAddress(name))then return nil end if(network.queueUpdates)then local addressIds=linq:select(network.addr[name].points,function(key,value,i)return value.id end):get()for k,id in ipairs(addressIds)do queue('network_address_removed',{name=name,id=id,anyLeft=false})end end network.addr[name]=nil end function network.clearAddresses()if(network.queueUpdates)then for name,addr in pairs(network.addr)do local addressIds=linq:select(addr.points,function(key,value,i)return value.id end):get()for k,id in ipairs(addressIds)do queue('network_address_removed',{name=name,id=id,anyLeft=false})end end end network.addr={}end function network.targetToAddress(target)local address if(type(target)=='table' and cAddress:is(target))then address=target elseif(type(target)=='string')then address=network.getAddress(target)end return address~=nil,address end function network.markAddressDropped(address)if(not cAddress:is(address))then return end address.dropped=address.dropped+1 if(address.dropped>2)then network.removeAddress(address.name,address.id)end end function network.markAddressReceived(address)if(not cAddress:is(address))then return end address.dropped=0 end function network.onNetworkAddressAdded(name,callback)on({event='network_address_added',filter=function(obj)return obj.name==name end,once=false,f=callback})if(network.hasAddress(name))then add(function()for k,v in ipairs(network.getAddresses(name))do callback(v)end end)end end function network.onNetworkAddressRemoved(name,callback)on({event='network_address_removed',filter=function(obj)return obj.name==name end,once=false,f=callback})if(not network.hasAddress(name))then add(function()callback({name=name,id=-1,anyLeft=false})end)end end function network.update(newAddresses)local seenTypes={}local anyChange=false for typ,addressList in pairs(newAddresses)do table.insert(seenTypes,typ)local ids=linq:select(addressList.points,function(k,v)return v.id end):get()local existingIds=network.getIds(typ)for k,existingId in ipairs(existingIds)do if(not linq:contains(ids,existingId))then anyChange=true network.removeAddress(typ,existingId)end end for k,newId in ipairs(ids)do if(not linq:contains(existingIds,newId))then anyChange=true network.addAddress(typ,newId)end end end for k,typ in ipairs(network.getTypes())do if(not linq:contains(seenTypes,typ))then anyChange=true network.clearAddress(typ)end end return anyChange end function network.open(side)if(not network.hasModem)then return false end if(rednet.isOpen())then return true end if(side~=nil)then pcall(rednet.open,side)else local i=1 local tbl={peripheral.find('modem',function(name,wrapped)return wrapped.isWireless()end)}while(not rednet.isOpen()and i<=#tbl)do pcall(rednet.open,peripheral.getName(tbl[i]))i=i+1 end end local isOpen=rednet.isOpen()if(isOpen)then log.logVerbose("Connected to network")else log.logWarning("Failed to connect to network")end return isOpen end function network.receive(timeout,filter,identifier)local receiveFilter=function(sender,message,protocol)return protocol==network.protocol and(filter and filter(sender,message,protocol))end local senderId,message,protocol if(timeout==nil)then senderId,message,protocol=coroutine.yield('rednet_message',receiveFilter)else local ourID=os.startTimer(timeout)local response=nil local handler=on({event='rednet_message',filter=receiveFilter,once=true,f=function(fSenderId,FMessage,fProtocol)response={fSenderId,FMessage,fProtocol or '_'}queue('timer',ourID)end})coroutine.yield('timer',function(id)return id==ourID end)if(response)then os.cancelTimer(ourID)senderId,message,protocol=unpack(response)else off('rednet_message',handler)end end if(senderId~=nil)then log.logVerbose("Received message from #",senderId,' for ',identifier or message.url)return message,senderId else log.logVerbose("Received no ",identifier or(message and message.url),"message within ",(timeout or-1)," seconds")return nil,nil end end function network.receiveMany(callback,timeout,filter,identifier)identifier=identifier or '' local eventHandler=on({event='rednet_message',filter=function(sender,message,protocol)return protocol==network.protocol and(filter==nil or filter(sender,message,protocol))end,once=false,f=function(sender,message,protocol)callback(message,sender)end})if(timeout~=nil)then wait(timeout)log.logVerbose("Network ",identifier,"receiver timed out")off('rednet_message',eventHandler)end end function network.broadcast(message)method.expect(1,message,'table')if(not network.open())then return nil end message.type=message.type or 'REQUEST' message.headers=message.headers or{}message.headers.sender=network.senderID message.headers.corID=message.headers.corID or math.random(0,9999)log.logVerbose("Broadcasting ",(message.url or "")," to network")return rednet.broadcast(message,network.protocol)end function network.send(message,receiver)method.expect(1,message,'table')method.expect(2,receiver,'number')if(not network.open())then return nil end message.headers=message.headers or{}message.headers.sender=network.senderID message.headers.corID=message.headers.corID or math.random(0,9999)log.logVerbose("Send to #",receiver,' at ',message.url)return rednet.send(receiver,message,network.protocol)end function network.respond(request,response)network.send({type='RESPONSE',url=request.url,method=request.method,headers={request=request,corID=request.headers.corID},body=response},request.headers.sender)end function network.get(...)return network._send('GET',...)end function network.post(...)return network._send('POST',...)end function network.put(...)return network._send('PUT',...)end function network._send(method,target,url,headers,body,timeout)local ok,address=network.targetToAddress(target)if(ok)then target=address.id end if(type(target)~='number')then log.logError("network.targetToAddress failed",type(target))return false end local message={type='REQUEST',method=method,url=url,headers=headers or{},body=body or{}}network.send(message,target)local responseMessage,responseSender=network.receive(timeout or 10,function(sender,received,protocol)return received.type=='RESPONSE' and received.headers.corID==message.headers.corID end)return responseMessage end if(console==nil)then console={}end console.oPrint=print console.output={}console.width,console.height=term.getSize()console.printLine=5 console.show=true console.printType=function(obj)local typ=type(obj)if(typ=='function')then return '#func' elseif(typ=='boolean')then return obj and 'true' or 'false' elseif(obj==nil)then return 'nil' else return obj end end print=function(...)local line if(...)then local tbl={}local args={...}for i=1,select("#",...)do tbl[i]=console.printType(args[i])end line=table.concat(tbl,' ')else line='' end table.insert(console.output,line)if(not console.show)then return end local y=math.max(2,math.min(console.printLine,console.height))local max=math.ceil(#line / console.width)for i=1,max do term.setCursorPos(1,y)if(y==console.height)then term.scroll(1)term.setCursorPos(1,y)else term.setCursorPos(1,y+1)end term.write(max==1 and line or string.sub(line,(console.width*(i-1))+1,console.width*i+1))y=math.min(y+1,console.height)end term.setCursorPos(1,1)term.clearLine()prebounce('term_redraw',console.redraw)console.printLine=y end on('mouse_scroll',function(direction)term.scroll(direction)prebounce('term_redraw',console.redraw)end)console.waitIndicators={[0]='','|','/','-','\\'}console.waitIndex=0 console.nested=0 function console.choice_impl(text,choices,add_space)local results={}for n=1,#choices do local option=choices[n] if #option+(add_space and 1 or 0)>#text and option:sub(1,#text)==text then local result=option:sub(#text+1)if add_space then table.insert(results,result.." ")else table.insert(results,result)end end end return results end function console.read(_sReplaceChar,consoletory,_fnComplete,_sDefault,_nTimeout,_bSpinner)if _sReplaceChar~=nil and type(_sReplaceChar)~="string" then error(string.join({"bad argument #1(expected string,got ",type(_sReplaceChar),")"},''),2)end if consoletory~=nil and type(consoletory)~="table" then error(string.join({"bad argument #2(expected table,got ",type(consoletory),")"},''),2)end if _fnComplete~=nil and type(_fnComplete)~="function" then error(string.join({"bad argument #3(expected function,got ",type(_fnComplete),")"},''),2)end if _sDefault~=nil and type(_sDefault)~="string" then error(string.join({"bad argument #4(expected string,got ",type(_sDefault),")"},''),2)end if _nTimeout~=nil and type(_nTimeout)~="number" and type(_nTimeout)~="function" then error(string.join({"bad argument #5(expected number or function,got ",type(_nTimeout),")"},''),2)end if _bSpinner~=nil and type(_bSpinner)~='boolean' then error(string.join({"bad argument #6(expected boolean,got ",type(_bSpinner),")"},''),2)elseif not _bSpinner then console.waitIndex=0 end term.setCursorBlink(true)console.nested=console.nested+1 local nested=console.nested local sLine='' local nPos=0 _sDefault=_sDefault or "" if _bSpinner and console.waitIndex==0 then console.waitIndex=1 end local nHistoryPos local _sDefaultLength=#(table.concat({console.waitIndicators[console.waitIndex],_sDefault},''))if _sReplaceChar then _sReplaceChar=string.sub(_sReplaceChar,1,1)end local tCompletions local nCompletion local function recomplete()if(console.nested~=nested)then return end if _fnComplete and nPos==string.len(sLine)then tCompletions=_fnComplete(sLine)if tCompletions and #tCompletions>0 then nCompletion=1 else nCompletion=nil end else tCompletions=nil nCompletion=nil end end local function uncomplete()if(console.nested~=nested)then return end tCompletions=nil nCompletion=nil end local w,h=term.getSize()local sx=1 local function redraw(_bClear)if(console.nested~=nested)then return end local nScroll=0 if sx+nPos+_sDefaultLength>=w then nScroll=(sx+nPos+_sDefaultLength)-w end term.setCursorPos(1,1)term.clearLine()local cx,cy=1,1 local sReplace=(_bClear and " ")or _sReplaceChar if sReplace then term.write(string.rep(sReplace,math.max(string.len(sLine)+_sDefaultLength-nScroll,0)))else term.write(string.sub(table.concat({console.waitIndicators[console.waitIndex],_sDefault,sLine},''),nScroll+1))end if nCompletion then local sCompletion=tCompletions[ nCompletion ] local oldText,oldBg if not _bClear then oldText=term.getTextColor()oldBg=term.getBackgroundColor()term.setTextColor(colors.white)term.setBackgroundColor(colors.gray)end if sReplace then term.write(string.rep(sReplace,string.len(sCompletion)))else term.write(sCompletion)end if not _bClear then term.setTextColor(oldText)term.setBackgroundColor(oldBg)end end term.setCursorPos(sx+nPos+_sDefaultLength-nScroll,1)end local function clear()if(console.nested~=nested)then return end redraw(true)end recomplete()redraw()local function acceptCompletion()if nCompletion then clear()local sCompletion=tCompletions[ nCompletion ] sLine=sLine..sCompletion nPos=string.len(sLine)recomplete()redraw()end end local currentTimer=nil local sessionID=math.random(0,1000)local timeoutFunction=nil if(type(_nTimeout)=='function')then local waitFunc=_nTimeout _nTimeout=nil timeoutFunction=add(function()waitUntil(waitFunc)queue('stopconsole',sessionID)end)end function _timer()if(_nTimeout~=nil)then add(function()local ourID=math.random(0,1000)currentTimer=ourID wait(_nTimeout,function()return currentTimer~=ourID end)if(currentTimer==ourID)then queue('stopconsole',sessionID)end end)end end local charListener=on('char',function(char)clear()sLine=string.join({string.sub(sLine,1,nPos),char,string.sub(sLine,nPos+1)},'')nPos=nPos+1 recomplete()redraw()_timer()end)local pasteListener=on('paste',function(paste)clear()sLine=string.join({string.sub(sLine,1,nPos),paste,string.sub(sLine,nPos+1)},'')nPos=nPos+string.len(paste)recomplete()redraw()_timer()end,function()return console.nested==nested end)local ctrlPressed=false local keyListener=on('key',function(key)if key==keys.enter then if(console.nested==nested)then if nCompletion then clear()uncomplete()redraw()end queue('stopconsole',sessionID)else sLine='' nPos=0 end elseif key==keys.left then if nPos>0 then clear()if(ctrlPressed)then local lineStart=string.sub(sLine,1,nPos):reverse()local subStart,subEnd=string.find(lineStart,'^%s*[^%s]*%s*')if(subStart)then nPos=nPos-(subEnd-subStart)-1 end else nPos=nPos-1 end recomplete()redraw()end elseif key==keys.right then if nPos<string.len(sLine)then clear()if(ctrlPressed and(nPos+1)<string.len(sLine))then local _,last=string.find(sLine,'^%s*[^%s]*%s*',nPos+1)nPos=last and(last-1)or nPos if((nPos+1)==string.len(sLine))then nPos=nPos+1 end else nPos=nPos+1 end recomplete()redraw()else acceptCompletion()end elseif key==keys.up or key==keys.down then if nCompletion then clear()if key==keys.up then nCompletion=nCompletion-1 if nCompletion<1 then nCompletion=#tCompletions end elseif key==keys.down then nCompletion=nCompletion+1 if nCompletion>#tCompletions then nCompletion=1 end end redraw()elseif consoletory then clear()if key==keys.up then if nHistoryPos==nil then if #consoletory>0 then nHistoryPos=#consoletory end elseif nHistoryPos>1 then nHistoryPos=nHistoryPos-1 end else if nHistoryPos==#consoletory then nHistoryPos=nil elseif nHistoryPos~=nil then nHistoryPos=nHistoryPos+1 end end if nHistoryPos then sLine=consoletory[nHistoryPos] nPos=string.len(sLine)else sLine='' nPos=0 end uncomplete()redraw()end elseif key==keys.backspace then if nPos>0 then clear()if(ctrlPressed)then local lineStart=string.sub(sLine,1,nPos):reverse()local subStart,subEnd=string.find(lineStart,'^%s*[^%s]*%s*')if(subStart)then local newStart=string.sub(lineStart,subEnd+1):reverse()sLine=string.join({newStart,string.sub(sLine,nPos+1)},'')nPos=#newStart end else sLine=table.concat({string.sub(sLine,1,nPos-1),string.sub(sLine,nPos+1)},'')nPos=nPos-1 end recomplete()redraw()end elseif key==keys.home then if nPos>0 then clear()nPos=0 recomplete()redraw()end elseif key==keys.delete then if nPos<string.len(sLine)then clear()if(ctrlPressed)then local _,last=string.find(sLine,'^%s*[^%s]*%s*',nPos+1)last=last or nPos sLine=string.join({string.sub(sLine,1,nPos),string.sub(sLine,last+1)},'')else sLine=string.join({string.sub(sLine,1,nPos),string.sub(sLine,nPos+2)},'')end recomplete()redraw()end elseif key==keys["end"] then if nPos<string.len(sLine)then clear()nPos=string.len(sLine)recomplete()redraw()end elseif key==keys.tab then acceptCompletion()elseif(key==keys.leftCtrl or key==keys.rightCtrl)then ctrlPressed=true end _timer()end)local keyUpListener=on('key_up',function(key)if(key==keys.leftCtrl or key==keys.rightCtrl)then ctrlPressed=false end _timer()end)local resizeListener=on('term_resize',function()w=term.getSize()if(console.nested==nested)then return end redraw()_timer()end)local redrawListener=on('term_redraw',function()redraw()end,function()return console.nested==nested end)local stopped=false local spinnerAction=_bSpinner and add(function()while(not stopped)do if(console.nested~=nested)then waitUntil(function()return console.nested==nested end)end console.waitIndex=(console.waitIndex % #console.waitIndicators)+1 prebounce('redraw',redraw)wait(0.2)end end)local quitListener=on({event='stopconsole',once=true,filter=function(eSessionID)return eSessionID==sessionID end,f=function()off('char',charListener)off('paste',pasteListener)off('key',keyListener)off('term_resize',resizeListener)off('term_redraw',redrawListener)if(_bSpinner)then off(spinnerAction)end off(timeoutFunction)stopped=true if nCompletion then clear()uncomplete()redraw()end end})_timer()waitUntil(function()return stopped end)local cx,cy=term.getCursorPos()if(console.nested==1)then term.setCursorBlink(false)else prebounce('term_redraw',console.redraw)end if(sLine~="")then term.clearLine()term.setCursorPos(1,1)end console.nested=console.nested-1 console.waitIndex=0 return sLine end function console.redraw()queue('term_redraw')end function console.clear()term.clear()term.setCursorPos(1,1)console.printLine=2 prebounce('term_redraw',console.redraw)end if(polly==nil)then polly={}end polly.retry=function(funcToRetry,funcStopCondition,delay)funcToRetry()while(not funcStopCondition())do wait(delay)funcToRetry()end end polly.retryWhileNil=function(funcToRetry,delay)local response=funcToRetry()local i=0 local increase=5 local maxWait=60 delay=delay or increase while(response==nil)do i=i+1 wait(delay)response=funcToRetry()if(delay+i*increase<maxWait)then delay=delay+i*increase end end return response end if(web==nil)then web={}end function web.printUsage()print("Usage:")print("web.getToFile<url><filename>")end function web.request(sUrl)http.request(sUrl,nil,nil,false)local fired,ok=false,false local response,err='','' local fOk=function(fUrl,fHandle)fired=true ok=true response=fHandle end local fFail=function(fUrl,fErr,fHandle)fired=true ok=false response=fHandle err=fErr end once{event="http_success",f=fOk,filter=function(fUrl)return fUrl==sUrl end}once{event="http_failure",f=fFail,filter=function(fUrl)return fUrl==sUrl end}waitUntil(function()return fired end)off("http_success",fOk)off("http_failure",fFail)return ok,response,err end function web.get(sUrl)log.logVerbose("Connecting to ",sUrl,"...")local fired,ok=false,false local err,response='',nil local checkF=once{event="http_check",f=function(fUrl,fOk,fErr)fired=true ok=fOk err=fErr end,filter=function(fUrl)return fUrl==sUrl end}if(not http.checkURLAsync(sUrl))then log.logError('web.get ',sUrl,' is invalid')off("http_check",checkF)return nil end waitUntil(function()return fired end)if not ok then log.logError('web.get ',sUrl,' not OK')if err then printError(err)end return nil end ok,response,err=web.request(sUrl)if not ok then log.logError('web.get ',sUrl,' did not respond')if err then printError(err)end return nil end if not response then return nil end local sResponse=response.readAll()response.close()return sResponse end function web.getToFile(...)local tArgs={...}if #tArgs<2 then web.printUsage()return end if not http then printError("wget requires http API")printError("Set http_enable to true in ComputerCraft.cfg")return end local sUrl=tArgs[1] local sFile=tArgs[2] local sPath=shell.resolve(sFile)local res=web.get(sUrl)if res then files.write(sPath,res)log.logVerbose("Downloaded as ",sFile)end return res end if(waiter==nil)then waiter={}end waiter.index=1 waiter.options={enabled=true,console=true,indicators={'|','/','-','\\'},timeout=0.2}function waiter.setOption(name,value)waiter.options[name]=value end function waiter.serve(command,...)local response local quit=false local args={...}local waitFunc=add(function()response={try(command,unpack(args))}quit=true end)waiter.wait(function()return quit end)off(waitFunc)return unpack(response or{})end function waiter.wait(waitFor)if(not waiter.options.enabled)then if(waitFor==nil)then return elseif(type(waitFor)=='function')then waitUntil(waitFor)elseif(type(waitFor)=='number')then wait(waitFor)end return end local timeout=waiter.options.timeout local indicators=waiter.options.indicators local quit=false if(waitFor~=nil)then if(type(waitFor)=='function' and waitFor())then return end add(function()if(type(waitFor)=='number')then wait(waitFor,function()return quit end)else waitUntil(function()return quit or waitFor()end)end quit=true end)end local waitFunc=function()return quit end local waitQuitCommands={'q','quit'}local x,y=term.getCursorPos()while(not quit)do if(waiter.options.console)then local qinput=console.read(nil,nil,nil,'>',waitFunc,true)quit=quit or linq:contains(waitQuitCommands,qinput or '')else term.setCursorPos(1,y)term.clearLine()term.setCursorPos(1,y)term.write(indicators[(waiter.index % #indicators)+1])term.setCursorPos(1,y+1)wait(timeout)waiter.index=waiter.index+1 end end term.setCursorPos(1,y)term.clearLine()waiter.index=waiter.index % #indicators end function receiveRequest(path,actionFunc,timeout)return receive(path,actionFunc,true,timeout)end function receiveResponse(path,actionFunc,timeout)return receive(path,actionFunc,false,timeout)end function _doesPathMatchPattern(path,pathPattern)local pathParts=string.split(path,'/')pathPattern=type(pathPattern)=='table' and pathPattern or string.split(pathPattern,'/')if(#pathParts~=#pathPattern)then return false end for k,v in ipairs(pathParts)do if(pathPattern[k]~='*' and v~=pathPattern[k])then return false end end return true end function receive(path,actionFunc,isRequest,timeout)local filterType=(isRequest or nil==isRequest)and 'REQUEST' or 'RESPONSE' local pathPattern=type(path)=='table' and path or string.split(path,'/')local callbackIntermediary=function(message,sender)actionFunc(message,string.split(message.url,'/'))end local filterFunction=function(sender,message,protocol)return message.type==filterType and _doesPathMatchPattern(message.url,pathPattern)end add(function()waitUntil(function()return state==nil or state.status~='podinitializing' end)network.receiveMany(callbackIntermediary,timeout,filterFunction)end)end if(stateH==nil)then stateH={}end stateH.id=os.getComputerID()state=state or{}stateH.init=function(params)params=params or{}state={id=stateH.id,sid=tostring(stateH.id),name=tostring(stateH.id),status=params.status or 'pending',types=params.types or{},elegibleTypes=params.elegibleTypes or{},spec={location=nil,facing='unknown',action=nil,network=network.addr},config={location={autoUpdate=params.autoUpdateLocation or false}},events={},data={}}return state end stateH.addType=function(newType)if(not linq:contains(state.types,newType))then table.insert(state.types,newType)queue('state_type_added',newType)end end stateH.removeType=function(existingType)if(linq:contains(state.types,existingType))then linq:where(state.types,function(k,v)return v==existingType end):remove()queue('state_type_removed',existingType)end end function stateH.onStateTypeAdded(name,callback)on({event='state_type_added',filter=name and function(t)return t==name end,once=false,f=callback})if(name and linq:contains(state.types,name))then add(function()callback()end)end end stateH.save=function()files.writeJson('state.json',state)end stateH.load=function()state=files.readJson('state.json')return state end receiveRequest('/status',function(request)network.respond(request,state)end)if(chat==nil)then chat={}end chat.commands={}chat.cmd=chat.commands chat.quitCommands={'exit','quit','stop'}chat.interactiveCommands={'clear'}chat.cmd.clear=console.clear chat.cmd['repeat']=function(count,func,...)if(chat.commands[func]==nil)then log.logWarning('no action specified')return end if(tonumber(count)==nil)then log.logWarning('number expected')return end for i=1,count do chat.commands[func](...)end end chat.cmd.id=function()print(state.id)end chat.actualCommands=nil chat.completeCommands=nil function chat.choice_complete(text)if(#text==0)then return{}end return console.choice_impl(text,chat.completeCommands,false)end function chat.add(name,func,opts)if(not opts)then chat.cmd[name]=func else setmetatable(opts,{__call=func})chat.cmd[name]=opts end end chat.history={}chat.maxHistory=20 function chat.run()local history=chat.history local commands=chat.commands if(chat.actualCommands==nil)then chat.actualCommands=linq:select(chat.commands,function(k,v)return k end):join(chat.quitCommands):get()end chat.completeCommands=linq:join(chat.actualCommands,history):get()local text=console.read(nil,history,chat.choice_complete,'>')if(text=='')then return true end if(linq:contains(chat.quitCommands,text))then return false end if(history[#history]~=text)then table.insert(history,text)if(#history>chat.maxHistory)then table.remove(history,1)end end local textParts=string.split(text,' ')local command=table.remove(textParts,1)if(commands[command])then if(linq:contains(chat.interactiveCommands,command))then return true,{commands[command],unpack(textParts)}else return true,{waiter.serve,commands[command],unpack(textParts)}end else log.logWarning('Unknown command ',text)end return true end function chat.runDirectly()local ok,task=chat.run()if(ok and task)then state.status='executing' try(table.unpack(task))state.status='running' end return ok end taskQueue={}add(function()while(true)do waitUntil(function()return #taskQueue>0 end)local task=table.remove(taskQueue,1)state.status='executing '..table.remove(task,1)try(table.unpack(task))state.status='running' end end)receiveRequest('/execute',function(request)print('received /execute')if(chat.cmd[request.body.func])then if(linq:contains(chat.interactiveCommands,request.body.func))then table.insert(taskQueue,{request.body.func,chat.cmd[request.body.func],table.unpack(request.body.params or{})})else table.insert(taskQueue,{request.body.func,waiter.serve,chat.cmd[request.body.func],table.unpack(request.body.params or{})})end end end)receiveRequest('/chat/commands',function(request)local keys={}for k,v in pairs(chat.cmd)do table.insert(keys,k)end network.respond(request,keys)end)if(election==nil)then election={}end election.elections={}function election.startElection(electionType)if(linq:contains(election.elections,electionType))then return false end table.insert(election.elections,electionType)local elected=false local isElegible=linq:contains(state.elegibleTypes,electionType)if(not isElegible)then network.broadcast({type='REQUEST',method='GET',url='/election/'..electionType,body={id=-1,electionType=electionType}})else local candidates=election.lookupCandidates(electionType)if(not linq:any(candidates))then log.logVerbose('No response on election ',electionType,',electing self')if(not linq:contains(state.types,electionType))then stateH.addType(electionType)end network.addAddress(electionType,state.id)network.broadcast({type='REQUEST',method='POST',url='/election/'..electionType..'/elected',body={id=state.id,electionType=electionType}})elected=true queue('elected',{self=true,electionType=electionType,id=state.id})end end table.remove(election.elections,linq:indexOf(election.elections,electionType))return elected end function election.lookupCandidates(electionType)local responses={}local electionUrl='/election/'..electionType receiveResponse(electionUrl,function(okResponse)if(okResponse==nil or okResponse.body.id==nil)then return end table.insert(responses,okResponse.body.id)end,2)network.broadcast({type='REQUEST',method='GET',url=electionUrl,body={id=state.id,electionType=electionType}})wait(2,function()return #responses>0 end)return responses end function election.whenElected(electionType,callbackFunc)add(function()if(linq:contains(state.types,electionType))then callbackFunc()end return on{event="elected",filter=function(election)return election.electionType==electionType and election.self end,f=callbackFunc}end)end receiveRequest('/election/*',function(request,urlParts)local isElegible=linq:contains(state.elegibleTypes,request.body.electionType)if(isElegible and request.body.id<state.id)then network.respond(request,{id=state.id})election.startElection(request.body.electionType)end end)receiveRequest('/election/*/elected',function(request,urlParts)network.clearAddress(request.body.electionType)network.addAddress(request.body.electionType,request.body.id)linq:where(election.elections,request.body.electionType):take(1):remove()if(request.body.id~=state.id)then stateH.removeType(request.body.electionType)end queue('elected',{self=false,electionType=request.body.electionType,id=request.body.id})log.logVerbose(request.body.electionType,' elected: ',request.body.id)end)if(networkHandling==nil)then networkHandling={}end networkHandling.discovery={inProgress=false,lastExecuted=nil,refreshInterval=60,didMyStateChange=false}stateH.onStateTypeAdded(nil,function()networkHandling.discovery.didMyStateChange=true end)networkHandling.updateHandlerRunning=false function networkHandling.discoveryLoop()if(networkHandling.updateHandlerRunning)then return end networkHandling.updateHandlerRunning=true while(linq:contains(state.types,'network'))do wait(networkHandling.discovery.refreshInterval)networkHandling.startNetworkDiscovery()end networkHandling.updateHandlerRunning=false end add(function()for k,typeName in ipairs(state.types)do network.addAddress(typeName,state.id)end network.onNetworkAddressRemoved('network',function(eventObj)if(network.hasModem and not eventObj.anyLeft)then if(not networkHandling.lookup('network'))then election.startElection('network')end end end)stateH.onStateTypeAdded('network',function()networkHandling.discoveryLoop()end)wait(math.random(1,2))if(network.hasModem and not getNetworkMap())then wait(3)networkHandling.startNetworkDiscovery()end if(state.status=='podinitializing')then state.status='pending' end end)function networkHandling.startNetworkDiscovery()log.logVerbose('Start network discovery')if(linq:contains(state.types,'network'))then log.logVerbose('I\'m already network')networkHandling.buildNetworkMap()log.logVerbose('Network discovery done')return end local success=getNetworkMap()if(not success)then election.startElection('network')wait(5,function()return network.hasAddress('network')end)networkHandling.startNetworkDiscovery()end log.logVerbose('network leaders:',string.join(network.getIds('network'),','))log.logVerbose('Network discovery done')end function getNetworkMap()log.logVerbose('getNetworkMap')if(linq:contains(state.types,'network'))then networkHandling.buildNetworkMap()return true end local retries=0 local networkHost=network.getCurrentAddress('network')or networkHandling.lookup('network')while(networkHost~=nil and networkHandling.testPodAlive('network')and retries<5)do retries=retries+1 local networkMapRequest=network.get('network','/network')if(networkMapRequest~=nil and networkMapRequest.body~=nil)then log.logVerbose('Updated network map')networkHandling.updateNetwork(networkMapRequest.body)return true end log.logWarning('Got empty network map,retry in 1 second')network.markAddressDropped(networkHost)wait(1)networkHost=network.getCurrentAddress('network')end return false end function networkHandling.buildNetworkMap()log.logVerbose('Build network map')networkHandling.discovery.inProgress=true local timeout=2 local addressMap={pod={state.id}}for k,typ in ipairs(state.types)do addressMap[typ]=addressMap[typ] or{}table.insert(addressMap[typ],state.id)end receiveResponse('/network/ping',function(response)local newAddr=response.body if(newAddr==nil or type(newAddr)~='table')then return end if(not linq:contains(addressMap.pod,newAddr.id))then table.insert(addressMap.pod,newAddr.id)for k,typ in ipairs(newAddr.types)do addressMap[typ]=addressMap[typ] or{}table.insert(addressMap[typ],newAddr.id)end end end,timeout)network.broadcast({type='REQUEST',method='GET',url='/network/ping'})wait(timeout)local anyChange=networkHandling.discovery.didMyStateChange local seenTypes={}for typ,ids in pairs(addressMap)do table.insert(seenTypes,typ)local existingIds=network.getIds(typ)for k,existingId in ipairs(existingIds)do if(not linq:contains(ids,existingId))then anyChange=true network.removeAddress(typ,existingId)end end for k,newId in ipairs(ids)do if(not linq:contains(existingIds,newId))then anyChange=true network.addAddress(typ,newId)end end end for typ in pairs(network.getAddresses())do if(not linq:contains(seenTypes,typ))then anyChange=true network.clearAddress(typ)end end if(anyChange)then networkHandling.discovery.didMyStateChange=false network.broadcast({type='REQUEST',method='POST',url='/network/update',body=network.getAddresses()})end local anyDuplicateNetworkLeaders=linq:any(addressMap.network or{},function(k,id)return id~=state.id end)if(anyDuplicateNetworkLeaders)then election.startElection('network')end networkHandling.discovery.inProgress=false end function networkHandling.updateNetwork(map)network.update(map)state.spec.network=network.addr end function networkHandling.lookup(name)if(not network.hasModem)then return nil end if(network.hasAddress(name))then return network.getAddress(name)end local responses={}local received=false local url='/network/lookup/'..name receiveResponse(url,function(response)response=response.body if(response==nil or linq:contains(responses,response))then return end table.insert(responses,response)received=true end,2)network.broadcast({type='REQUEST',method='GET',url=url})wait(2,function()return received end)for k,response in ipairs(responses)do if(response==state.id or networkHandling.testPodAlive(response))then network.addAddress(name,response)if(response==state.id and not linq:contains(state.types,name))then stateH.addType(name)end end end return network.getAddress(name)end function networkHandling.testPodAlive(address)if(address==nil)then return false end local health=network.get(address,'/health',nil,nil,2)return health~=nil end receiveRequest('/health',function(request)network.respond(request,true)end)receiveRequest('/network',function(request)local condition=function()return not networkHandling.discovery.inProgress end wait(5,condition)if(condition())then network.respond(request,network.getAddresses())end end)receiveRequest('/network/update',function(request)networkHandling.updateNetwork(request.body)end)receiveRequest('/network/lookup/*',function(request,urlParts)waitUntil(function()return not networkHandling.discovery.inProgress end)local r=network.getAddress(urlParts[3])if(r~=nil and r.id~=nil)then network.respond(request,r.id)end end)receiveRequest('/network/ping',function(request)network.respond(request,{types=state.types,id=state.id})debounce('/network/ping',function()election.startElection('network')end,networkHandling.discovery.refreshInterval*3+1)end)election.whenElected('network',function()networkHandling.buildNetworkMap()end)if(cachehandling==nil)then cachehandling={}end cachehandling.updateChecked=false function updateFileCache()if(not network.hasAddress('cache'))then return end local url='/luacache/'..thisFile local responseFile=network.get('cache',url)if(responseFile==nil)then error('Got empty response on ',url)end log.logVerbose('Found ',thisFile,' file from cache')files.write('startup.lua',responseFile.body.content)state.data.cacheupdate=os.time('local')stateH.save()log.logWarning('Rebooting for cache...')wait(1)os.reboot()end add(function()wait(30,function()return cachehandling.updateChecked or(network.hasAddress('cache')and not linq:contains(state.types,'cache'))end)if(not(network.hasAddress('cache')and not linq:contains(state.types,'cache')))then log.information('Skip update check')return end local lastUpdated=state.data.cacheupdate or 0 local url='/luacache/'..thisFile..'/lastChecked' local response=network.get('cache',url)if(response~=nil)then local diff=response.body-lastUpdated if(diff>0.002)then wait(2)updateFileCache()end else log.logVerbose('Cache server did not respond to ',url)end end)receiveRequest('/luacache',function(message,urlParts)if(linq:contains(state.types,'cache'))then return end log.logInfo('Received message ',message.url,' from ',message.headers.sender)if(not network.hasAddress('cache'))then network.addAddress('cache',message.headers.sender)end if(linq:contains(message.body,thisFile))then updateFileCache()end log.logVerbose('Message handling ',message.url,' from ',message.headers.sender,' done')end)add(function()if(not linq:contains(state.elegibleTypes,'cache'))then return nil end cachehandling.indexFile='https://raw.githubusercontent.com/latens/bug-free-octo-couscous-index/refs/heads/main/index.prod.json' cachehandling.cacheConfigFile='cache.json' cachehandling.refreshInterval=60 cachehandling.cache=files.readJson(cachehandling.cacheConfigFile)or{files={},lastChecked=0,latestChanges={},}function cachehandling.updateCache()local now=os.time('local')log.logVerbose('Update cache ',now)local latestChanges={}local index=polly.retryWhileNil(function()return web.get(cachehandling.indexFile)end)index=textutils.unserialiseJSON(index)for _,file in ipairs(index.files or index)do if(cachehandling.cache.files[file.name]==nil)then cachehandling.cache.files[file.name]={diskPath='cache/'..file.name,changeID=file.changeID-1,name=file.name}end local cachedFile=cachehandling.cache.files[file.name] if(cachedFile.changeID<file.changeID)then table.insert(latestChanges,cachedFile.name)cachedFile.changeID=file.changeID web.getToFile((index.baseUrl or 'https://raw.githubusercontent.com/latens/bug-free-octo-couscous-index/refs/heads/main/files/prod/')..file.name,cachedFile.diskPath)cachedFile.updatedAt=now end end cachehandling.cache.latestChanges=latestChanges cachehandling.cache.lastChecked=now files.writeJson(cachehandling.cacheConfigFile,cachehandling.cache)end function cachehandling.getCachedFileContent(name)return files.read(cachehandling.cache.files[name].diskPath)end function cachehandling.getCachedContent()local response={}for name,opts in pairs(cachehandling.cache.files)do table.insert(response,{name=name,content=cachehandling.getCachedFileContent(name)})end return response end network.onNetworkAddressRemoved('cache',function(eventObj)if(not eventObj.anyLeft or not networkHandling.lookup('cache'))then election.startElection('cache')end end)network.onNetworkAddressAdded('cache',function(eventObj)if(eventObj.id~=state.id and linq:contains(state.types,'cache'))then election.startElection('cache')end end)cachehandling.updateHandlerRunning=false function cachehandling.cacheUpdateHandler()if(cachehandling.updateHandlerRunning)then return end cachehandling.updateHandlerRunning=true wait(2)try(function()repeat cachehandling.updateCache()local changes=cachehandling.cache.latestChanges if(linq:any(changes))then if(network.hasModem)then log.logInformation('Broadcasting file updates ')network.broadcast({type='REQUEST',method='POST',url='/luacache',body=changes})wait(5)else log.logInformation('Update found')wait(1)end if(linq:contains(changes,thisFile))then local content=files.read('cache/'..thisFile)files.write('startup.lua',content)log.logWarning('Rebooting...')os.reboot()end end cachehandling.cache.latestChanges={}wait(cachehandling.refreshInterval)until(not linq:contains(state.types,'cache'))end)cachehandling.updateHandlerRunning=false end stateH.onStateTypeAdded('cache',function()cachehandling.cacheUpdateHandler()end)receiveRequest('/luacache/*/lastChecked',function(request,urlParts)local fileName=urlParts[2] network.respond(request,cachehandling.cache.files[fileName].updatedAt)end)receiveRequest('/luacache',function(request)network.respond(request,cachehandling.getCachedContent())end)receiveRequest('/luacache/*',function(request,urlParts)local fileName=urlParts[2] local content=cachehandling.getCachedFileContent(fileName)network.respond(request,{name=fileName,content=content})end)end)thisFile='smelter.lua' print('v1.3')if(smelter==nil)then smelter={}end if(not stateH.load())then stateH.init({types={'smelter'},elegibleTypes={'cache','smelter'}})end chat.cmd.compact=function(inventory)inventory=inventory or peripheral.find('minecraft:chest')local inv=generic_inventory.init(inventory.list())local iName=peripheral.getName(inventory)local moves=generic_inventory.get_compact_moves(inv)if(#moves>0)then local tasks=parallel:new()for k,v in ipairs(moves)do tasks:add(function()inventory.pushItems(iName,v[1],64,v[2])end)end tasks:run()end end smelter.getItemStats=function(inventory,search)local items={}local itemCount={}for slot,item in pairs(inventory)do if(item.name:match(search))then items[item.name]=items[item.name] or{}table.insert(items[item.name],{slot=slot,count=item.count})itemCount[item.name]=itemCount[item.name] or 0 itemCount[item.name]=itemCount[item.name]+item.count end end local maxCount=0 local maxName=nil for name,count in pairs(itemCount)do if(count>maxCount)then maxCount=count maxName=name end end if(maxName~=nil)then tables.sortByDescending(items[maxName],'count')return items[maxName],maxCount end end smelter._pushItems=function(source,to,slot,items,count)local index=1 local item=items[index] while(count>0)do while(item.count<=0 and index<#items)do index=index+1 item=items[index] end if(item.count<=0)then break end local pushed=source.pushItems(to,item.slot,math.min(item.count,count),slot)item.count=item.count-pushed count=count-pushed end end chat.cmd.smelt=function(target)target=target or 'log' local chests={peripheral.find('minecraft:chest',function(name,modem)return not linq:contains(var.sides,name)end)}local furnaces={peripheral.find('minecraft:furnace',function(name,modem)return not linq:contains(var.sides,name)end)}local chest=chests[1] chat.cmd.compact(chest)local todo=parallel:new()local availableFurnaces={}for k,furnace in ipairs(furnaces)do todo:add(function()local slots=furnace.list()if(furnace.getCookTime()==0)then local f={name=peripheral.getName(furnace),funcs=furnace}if(slots[1]~=nil)then chest.pullItems(f.name,1)end slots[2]=slots[2] or{count=0}if(slots[3]~=nil)then chest.pullItems(f.name,3)end f.remainingFuel=math.max(0,furnace.getRemainingBurnTime()-50)f.fuel=math.floor(f.remainingFuel+furnace.getBurnTime()*slots[2].count)/ 200 table.insert(availableFurnaces,f)end end)end todo:run()chat.cmd.compact(chest)local inventory=chest.list()local fuelItems,coalCount=smelter.getItemStats(inventory,'coal')local targetItems,targetCount=smelter.getItemStats(inventory,target)if(fuelItems==nil)then print('no fuel items found')return end if(targetItems==nil)then print('no',target,'found')return end local smeltersToUse=math.min(math.min(math.ceil(targetCount / 8),#availableFurnaces),coalCount)local minItemsPerSmelter=math.min(64,math.floor((targetCount/8)/ #availableFurnaces)*8)local expectedRemainder=targetCount-(minItemsPerSmelter*smeltersToUse)local carryOver=(minItemsPerSmelter==64 or expectedRemainder<=0)and 0 or expectedRemainder local carryOverCount=math.ceil(carryOver / 8)todo:clear()tables.sortByDescending(availableFurnaces,'remainingFuel','fuel')for k,v in ipairs(availableFurnaces)do todo:add(function()local itemsToPush=k<=carryOverCount and(minItemsPerSmelter+8)or minItemsPerSmelter if(v.fuel<itemsToPush)then smelter._pushItems(chest,v.name,2,fuelItems,math.ceil((itemsToPush-v.fuel)/8))end smelter._pushItems(chest,v.name,1,targetItems,itemsToPush)end)if(smeltersToUse==k)then break end end todo:run()add(function()wait(minItemsPerSmelter*10+(carryOver>0 and math.min(80,carryOver*10)or 0))todo:clear()for k,v in ipairs(availableFurnaces)do todo:add(function()chest.pullItems(v.name,3)end)if(smeltersToUse==k)then break end end todo:run()end)end chat.cmd.network=network.printAddresses run(function()while(chat.runDirectly())do stateH.save()end end)
