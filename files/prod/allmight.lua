print('10/19/2024 21:21:50')
         if(Location==nil)then Location={}end Location.isLocation=true function Location:__eq(other)return type(other)=='table' and other.isLocation and other.x==self.x and other.y==self.y and other.z==self.z end function Location:__add(other)if(type(other)~='table' or not other.isLocation)then error('Can not add Location to type '..type(other))end return Location:new(other.x+self.x,other.y+self.y,other.z+self.z)end function Location:__sub(other)if(type(other)~='table' or not other.isLocation)then error('Can not sub Location from type '..type(other))end return Location:new(self.x-other.x,self.y-other.y,self.z-other.z)end function Location:__tostring()return "X:"..self.x.." Y:"..self.y.." Z:"..self.z end function Location:new(x,y,z)if(type(x)=='table')then if(#x<3)then error('Expected the first argument of Location:new to be a table with 3 elements')end z=x.z or x[3] y=x.y or x[2] x=x.x or x[1] end o={x=x or 1,y=y or 1,z=z or 1,x or 1,y or 1,z or 1}setmetatable(o,self)self.__index=self return o end function Location:distance2d(other)local diff=self-other return math.abs(diff.x)+math.abs(diff.y)end Responder={}Responder.__index=Responder if(Responder==nil)then Responder={}end function Responder:new(functionToWrap)assert(self,"missing receiver")local r=setmetatable({},self)r.func=functionToWrap r.co=coroutine.create(r.func)if(r.co==nil)then error('Could not create new responder')end return r end function Responder:__call(...)if self:canResume()then local response={coroutine.resume(self.co,...)}if(not response[1])then print('ERR: in Responder:__call')print(response[2])end table.remove(response,1)if(type(response[1])=='function')then self.check=response[1] table.remove(response,1)end return true,response else return false end end function Responder:stop()self.co=nil end function Responder:finished()return self.co==nil or coroutine.status(self.co)=="dead" end function Responder:canResume()if not self:finished()then if self.check then return self:check()else return true end end return false end function string.starts(String,Start)return string.sub(String,1,string.len(Start))==Start end function string.before(String,Start)return string.sub(String,1,string.len(Start))end function string.after(String,Start)return string.sub(String,string.len(Start)+1)end function string.split(inputstr,sep)if sep==nil then sep="." end local t={}for str in string.gmatch(inputstr,"([^"..sep.."]+)")do table.insert(t,str)end return t end function string.trim(s)return(string.gsub(s,"^%s*(.-)%s*$","%1"))end function string.join(params,glue)if(#params==1)then return tostring(params[1])end glue=glue or '.' local t={}for k,v in ipairs(params)do t[#t+1]=tostring(v)end return table.concat(t,glue)end function firstToUpper(str)return(str:gsub("^%l",string.upper))end if(class==nil)then class={}end class=function(classDef,parentClass)if classDef.super or classDef.new or classDef.is then error("super and new can not exist within class defenitions",2)end if parentClass then setmetatable(classDef,{__index=parentClass})classDef.super=parentClass end function classDef:new(...)local new={}setmetatable(new,{__index=self})if new.constructor then new:constructor(...)end return new end function classDef:is(c)local selfTable=getmetatable(self)local cTable=getmetatable(c)return(selfTable~=nil and c==selfTable.__index)or(cTable~=nil and self==cTable.__index)end return classDef end if(convert==nil)then convert={}end function convert.toJson(message)return textutils.serialise(message)end function convert.fromJson(message)if(type(message)=="table")then return message end if(type(message)=="string")then return textutils.unserialise(message)end return nil end function convert.isJson(message)local json=convert.fromJson(message)return json~=nil,json end function convert.toLocation(loc,y,z)local location={}if(loc==nil)then return location end if(type(loc)=="table")then location.x=tonumber(loc.x)or tonumber(loc[1])or 0 location.y=tonumber(loc.y)or tonumber(loc[2])or 0 location.z=tonumber(loc.z)or tonumber(loc[3])or 0 else location.x=tonumber(loc)or 0 location.y=tonumber(y)or 0 location.z=tonumber(z)or 0 end location[1]=location.x location[2]=location.y location[3]=location.z return location end if(files==nil)then files={}end function files.write(name,content)local file=fs.open(name,"wb")file.write(content)file.close()end function files.read(name)if(not fs.exists(name))then return nil end local file=fs.open(name,"r")local contents=file.readAll()file.close()return contents end function files.writeJson(name,content)return files.write(name,textutils.serialiseJSON(content))end function files.readJson(name)local content=files.read(name)return content and textutils.unserialiseJSON(content)or nil end if(method==nil)then method={}end local native_select,native_type=select,type local function get_type_names(...)local types=table.pack(...)for i=types.n,1,-1 do if types[i]=="nil" then table.remove(types,i)end end if #types<=1 then return tostring(...)else return table.concat(types,",",1,#types-1).." or "..types[#types] end end function method.expect(index,value,...)local t=native_type(value)for i=1,native_select("#",...)do if t==native_select(i,...)then return value end end local name local ok,info=pcall(debug.getinfo,3,"nS")if ok and info.name and info.name~="" and info.what~="C" then name=info.name end local type_names=get_type_names(...)if name then error(("bad argument #%d to '%s'(expected %s,got %s)"):format(index,name,type_names,t),3)else error(("bad argument #%d(expected %s,got %s)"):format(index,type_names,t),3)end end if(var==nil)then var={}end var.sides={"right","left","up","down","front","back"}var.directions={"north","east","south","west"}if(try==nil)then try={}end try=setmetatable(try,{__call=function(self,func,...)local result={pcall(func,...)}if(table.remove(result,1))then return unpack(result)else print('ERR','try()',result[1])end end})function try.catch(startFunc,catchFunc)local result={pcall(startFunc)}if(table.remove(result,1))then return unpack(result)else catchFunc(result[1])end end if(positions==nil)then positions={}end function positions.calcFacingStartStop(start,stop)if(not start.isLocation or not stop.isLocation)then error('Requires Locations as input types')end if(start==stop)then return "unknown","unknown" end local xDiff=start.x-stop.x local yDiff=start.y-stop.y local xD=xDiff>0 and "west" or(xDiff<0)and "east" or "" local yD=yDiff>0 and "north" or(yDiff<0)and "south" or "" local function combineDirection()if(xD~="" and yD~="")then return string.join({yD,xD},'-')end return yD..xD end if(math.abs(xDiff)>math.abs(yDiff))then return xD,combineDirection()elseif(math.abs(xDiff)<math.abs(yDiff))then return yD,combineDirection()end return xD,combineDirection()end function positions.reverseDirection(dir)if(dir=='north')then return 'south' elseif(dir=='east')then return 'west' elseif(dir=='south')then return 'north' elseif(dir=='west')then return 'east' end return 'unknown' end if(tables==nil)then tables={}end function tables.removeMany(t,fnRemove)if(fnRemove==nil)then return t end local typ=type(fnRemove)local j,n=1,#t if(typ=='function')then for i=1,n do if(fnRemove(t,i,j))then t[i]=nil; else if(i~=j)then t[j]=t[i]; t[i]=nil; end j=j+1; end end else for i=1,n do if(t[i]==fnRemove)then t[i]=nil; else if(i~=j)then t[j]=t[i]; t[i]=nil; end j=j+1; end end end if(#t>j)then n=#t for i=j,n do if(t[i]~=nil)then if(i~=j)then t[j]=t[i]; t[i]=nil; end j=j+1; end end end return t; end function tables.iShallowCopy(t)if(#t==0)then return t end local t2={}for k,v in ipairs(t)do t2[k]=v end return t2 end function tables.deepCopy(t)local t2={}for k,v in pairs(t)do if(type(v)=='table')then t2[k]=tables.deepCopy(v)else t2[k]=v end end return t2 end function tables.immutableInsert(t,item,index)index=index or(#t+1)local newT=tables.iShallowCopy(t)table.insert(newT,index,item)return newT end function tables.sortBy(t,property)table.sort(t,function(a,b)return a[property]<b[property] end)return t end function tables.sortByDescending(t,property)table.sort(t,function(a,b)return a[property]>b[property] end)return t end tables.sortByAscending=tables.sortBy if(linq==nil)then linq={}end if(_linq==nil)then _linq={}end function _linq._iterator(self,iteratorfunc)for i,keyvalue in ipairs(self.cache)do coroutine.yield(keyvalue[1],keyvalue[2],i)end local i=#self.cache+1 if(not self.done and self.parent~=nil)then local pIterator=self.parent.getIterator()local pDone,pKey,pValue=pIterator()while(not pDone and pKey~=nil and not self.done)do if(self.filter==nil or self.filter(pKey,pValue,i,self))then if(iteratorfunc)then pKey,pValue=iteratorfunc(pKey,pValue,i,self)end self.cache[i]={pKey,pValue}coroutine.yield(pKey,pValue,i)i=i+1 end pDone,pKey,pValue=pIterator()end end if(not self.done and self.data)then for k,v in pairs(self.data)do if(not self.done and self.filter==nil or self.filter(k,v,i,self))then if(iteratorfunc)then k,v=iteratorfunc(k,v,i,self)end self.cache[i]={k,v}coroutine.yield(k,v,i)i=i+1 end end end end function _linq._wrap(func)local co=Responder:new(func)return function(...)_,response=co()if(not co:canResume())then return true end if(type(response)~='table')then error('expected table')end response=response or{}return false,response[1],response[2] end end linq=class({constructor=function(self,params)self.new=nil self.isLinq=true local data,filter,iterator,parent=params.data,params.filter,params.iterator,params.parent self.getIterator=function()return _linq._wrap(function()if(iterator)then iterator(self)else _linq._iterator(self)end self.done=true end)end if(type(filter)=='string' or type(filter)=='number')then filter=function(k,v)return v==filter end end self.filter=filter self.cache={}self.data=data self.parent=parent end,cache=nil,data=nil,done=false,filter=nil,parent=nil,isLinq=false,newSubQuery=function(self,params)params.parent=self return linq:new(params)end})function linq:where(data,func)if(func~=nil)then return linq:new({data=data,filter=func})else func=data return self:newSubQuery({filter=func})end end function linq:take(data,count)if(count~=nil)then return linq:new({data=data,filter=function(k,v,i,self)self.done=i==count return k<=count end})else count=data return self:newSubQuery({filter=function(k,v,i,self)self.done=i==count return i<=count end})end end function linq:skip(data,count)if(count~=nil)then count=count+1 return linq:new({data=data,filter=function(k,v,i)count=count-1 return k>count end})else count=data+1 return self:newSubQuery({filter=function(k,v,i)count=count-1 return k>count end})end end function linq:join(dataA,dataB)if(dataB==nil)then dataA,dataB=self,dataA if(not dataA.isLinq)then error('linq:join expected two arguments')end end if(dataA.isLinq)then if(dataB.isLinq)then return linq:new({iterator=function()_linq._iterator(dataA)_linq._iterator(dataB)end})else return self:newSubQuery({data=dataB})end else return linq:new({parent=linq:new({data=dataA}),data=dataB})end end function linq:reverse()local oldSelf=self return linq:new({iterator=function(self)self.data={}local tempData={}oldSelf:each(function(k,v)table.insert(tempData,{k,v})end)local y=1 for i=#tempData,1,-1 do self.data[y]=tempData[i] y=y+1 end tempData=nil _linq._iterator(self,function(key,value)return value[1],value[2] end)end})end function linq:getSorted(data,func)if(data==nil)then return linq:getSorted(self:get())elseif(func==nil)then table.sort(data)return data elseif(type(func)=='function')then table.sort(data,func)return data else print('linq:sort','unknown arguments',data,func)end end function linq:get()local data={}local iterator=self.getIterator()local pDone,pKey,pValue=iterator()while(not pDone)do table.insert(data,pValue)pDone,pKey,pValue=iterator()end return data end function linq:first(data)if(data==nil)then local iterator=self.getIterator()local pDone,pKey,pValue=iterator()return not pDone and pValue else for k,v in pairs(data)do return v end end end function linq:last()local iterator=self.getIterator()local pDone,pKey,pValue=iterator()local last=pValue while(not pDone)do last=pValue pDone,pKey,pValue=iterator()end return last end function linq:_cache()local iterator=self.getIterator()while(not iterator())do end end function linq:any(data,funcOrData)if(data==nil)then local iterator=self.getIterator()local pDone=iterator()return not pDone elseif(type(funcOrData)=='function')then for k,v in pairs(data)do if(funcOrData(k,v))then return true end end return false elseif(funcOrData~=nil)then for k,v in pairs(data)do if(v==funcOrData)then return true end end return false elseif(type(data)=='table')then for k,v in pairs(data)do return true end return false else return self:where(data):any()end end linq.contains=linq.any function linq:each(data,func)if(func==nil)then func=data return self:newSubQuery({iterator=function(self)_linq._iterator(self,func)end}):get()else return linq:new({data=data,iterator=function(self)_linq._iterator(self,func)end}):get()end end function linq:select(data,func)if(func==nil)then func=data return self:newSubQuery({iterator=function(self)_linq._iterator(self,function(k,v)return k,func(k,v)end)end})else return linq:new({data=data,iterator=function(self)_linq._iterator(self,function(k,v)return k,func(k,v)end)end})end end linq.map=linq.select function linq:remove()local function getData(linqItem)if(linqItem.parent~=nil)then return getData(linqItem.parent)end return linqItem.data end local data=getData(self)self:reverse():each(function(k,v)table.remove(data,k)end)end function linq:indexOf(data,obj)if(obj==nil)then obj=data return self:where(function(k,v)return v==obj end):select(function(k)return k end):first()else return linq:new({data=data}):indexOf(obj)end end if(log==nil)then log={}end loglevel=settings.get('loglevel')or 3 function log.setLoglevel(level)if(type(level)=="string")then if(level=="error")then loglevel=4 end if(level=="warning")then loglevel=3 end if(level=="info" or level=="information")then loglevel=2 end if(level=="verbose")then loglevel=1 end settings.set("loglevel",loglevel)elseif(type(level)=="number")then loglevel=level settings.set("loglevel",level)end end function log._log(filter,...)if(loglevel<=filter)then print(string.join({...},''))return true else return false end end function log.logError(...)return log._log(4,...)end function log.logWarning(...)return log._log(3,...)end function log.logInformation(...)return log._log(2,...)end function log.logVerbose(...)return log._log(1,...)end function log.bool(boolean)return boolean and 'true' or 'false' end log.logInfo=log.logInformation if(miner==nil)then miner={}end function miner.excavate()miner.checkUp()miner.checkForward()miner.checkLeft()miner.checkLeft()miner.checkLeft()turtle.turnLeft()miner.checkDown()end function miner.checkUp()local ok,ins=turtle.inspectUp()if(ok and ins.name:match('_ore'))then turtle.digUp()turtle.up()miner.excavate()turtle.down()end end function miner.checkForward()local ok,ins=turtle.inspect()if(ok and ins.name:match('_ore'))then turtle.dig()turtle.forward()miner.excavate()turtle.back()end end function miner.checkDown()local ok,ins=turtle.inspectDown()if(ok and ins.name:match('_ore'))then turtle.digDown()turtle.down()miner.excavate()turtle.up()end end function miner.checkLeft()turtle.turnLeft()miner.checkForward()end if(rx==nil)then rx={}end function rx.errorWrapper(f,name,errType)return function(...)local ok,err=pcall(f,...)if(not ok)then print('ERR:',errType or '',name or '')print(err)end end end EventTable={}EventTable.__index=EventTable function EventTable:on(optsOrName,f)local opts if type(optsOrName)=="table" then opts=optsOrName else opts={event=optsOrName,f=f}end local name=opts.event assert(type(name)=="string" and name~="",":on requires an event name")assert(type(opts.f)=="function",":on requires an event handler")if(opts.handler)then opts.fWrapped=opts.handler else opts.fWrapped=rx.errorWrapper(opts.f,name,'EVENT')end self[name]=self[name] or{}table.insert(self[name],opts)return opts.f end function EventTable:off(name,responder)if responder and self[name] then tables.removeMany(self[name],function(t,i)return t[i].f==responder end)elseif(type(name)=='string')then self[name]=nil elseif(type(name)=='function')then if(self['timer'])then tables.removeMany(self['timer'],function(t,i)return t[i].f==name end)end tables.removeMany(self._unfinishedResponders,function(t,i)return t[i].func==name end)end end function EventTable:dispatch(name,...)if(self[name]==nil or #self[name]==0)then return false end local sent=false local args={...}tables.removeMany(self[name],function(t,i)local responder=t[i] if type(responder.filter)=="function" and not responder.filter(table.unpack(args))then return false else local f,ok,fResult if(responder.handler)then f=responder.handler ok,fResult=f(name,table.unpack(args))else f=Responder:new(responder.fWrapped)ok,fResult=f(table.unpack(args))end sent=true if not f:finished()then if(type(fResult)=='table' and type(fResult[1])=='string')then local event,filter=fResult[1],fResult[2] if(responder.handler and name==event)then responder.filter=type(filter)=='function' and filter return false else self:on({event=event,handler=f,f=responder.f,filter=type(filter)=='function' and filter,once=false})end else self:addResponder(f)end end return responder.handler~=nil or responder.once end end)return sent end function EventTable:addResponder(responder)table.insert(self._unfinishedResponders,responder)end function EventTable:resume()local newUnfinishedResponders={}for _,responder in ipairs(self._unfinishedResponders)do local ok,fResult=responder()if not responder:finished()then if(type(fResult)=='table' and type(fResult[1])=='string')then self:on({event=fResult[1],handler=responder,f=responder.func,filter=type(fResult[2])=='function' and fResult[2],once=false})else table.insert(newUnfinishedResponders,responder)end end end self._unfinishedResponders=newUnfinishedResponders end function EventTable:new()assert(self,"missing receiver")local et=setmetatable({},self)et._unfinishedResponders={}return et end local osEvents=EventTable:new()function on(...)return osEvents:on(...)end function off(...)return osEvents:off(...)end function add(func)local responder=Responder:new(rx.errorWrapper(func,'add'))osEvents:addResponder(responder)return responder.func end function queue(...)os.queueEvent(...)end function waitUntil(checkFunc)if(not checkFunc())then coroutine.yield(checkFunc)end end function once(event,func,filter)if(type(event)=='table')then local opts=event event=opts.event func=opts.f or opts.func filter=opts.filter end return on{event=event,filter=filter,once=true,f=func}end function wait(seconds,cancelFunction)local ourID=os.startTimer(seconds)if(cancelFunction~=nil)then local fired=false local onListener=on{event="timer",filter=function(timerID)return timerID==ourID or fired end,once=true,f=function()fired=true end}waitUntil(function()return fired or cancelFunction()end)off('timer',onListener)os.cancelTimer(ourID)else coroutine.yield('timer',function(id)return id==ourID end)end end function waitForEvent(event,filter)return coroutine.yield(event,filter)end rx.debouncers={}function debounce(name,func,timeout)rx.debouncers[name]=rx.debouncers[name] or{}local db=rx.debouncers[name] if(timeout)then if(db.id)then os.cancelTimer(db.id)off('timer',db.on)end db.id=os.startTimer(timeout)db.on=on{event="timer",filter=function(timerID)return timerID==db.id end,once=true,f=function()rx.debouncers[name]=nil func()end}else if(db.on)then off(db.on)end db.on=add(function()rx.debouncers[name]=nil func()end)end end function run(mainFunction)mainFunction=mainFunction or function()while(true)do wait(10)end end if mainFunction then ok,err=pcall(add,function()mainFunction()quit()end)if(not ok)then print('run err')print(err)end ok,err=pcall(osEvents.resume,osEvents)if(not ok)then print('run err2')print(err)end end while true do local event={os.pullEventRaw()}local eventName=event[1] local handled=osEvents:dispatch(unpack(event))if not handled then if eventName=="terminate" then print("Shutting down")break end end osEvents:resume()end end function quit()queue('terminate')end if(backpack==nil)then backpack={}end backpack.vars={trash={':stone','dirt','cobble','flower','gravel','granite','andesite','diorite','deepslate$'},smeltable={'_ore','log'},fuel={'coal','log','stick','plank'}}if(not _HOST:match('Minecraft 1.12'))then backpack.vars.smeltable[1]='raw_%w+$' end local backpack_inventory_meta={__index={foreach=function(self,func)for slot,item in pairs(self)do if(item and item.count>0)then func(slot,item)end end end,where=function(self,func)for slot,item in pairs(self)do if(item and item.count>0 and func(slot,item))then return slot,item end end end,update=function(self)return backpack.getInventory(self)end}}function backpack.getInventory(inventory)local inventory=inventory or setmetatable({},backpack_inventory_meta)for slot=1,16 do inventory[slot]=turtle.getItemDetail(slot)end return inventory end function backpack.isFull(inventory)inventory=inventory or backpack.getInventory()for slot,item in pairs(inventory)do if(item==nil or item.count==0)then return false end end return false end function backpack.getSlotWith(name,inventory)inventory=inventory or backpack.getInventory()if(type(name)=='string')then return inventory:where(function(slot,item)return item.name==name or item.name:match(name)end)elseif(type(name)=='table')then for k,v in ipairs(name)do local slot=backpack.getSlotWith(v,inventory)if(slot)then return slot end end end end function backpack.getCount(name,inventory)inventory=inventory or backpack.getInventory()local totalCount={}local types={}inventory:foreach(function(slot,item)local slotName=item.name if(slotName:match(name))then if(not totalCount[slotName])then totalCount[slotName]={name=slotName,count=0}table.insert(types,totalCount[slotName])end totalCount[slotName].count=totalCount[slotName].count+item.count end end)if(#types>0)then tables.sortByDescending(types,'count')return types[1].count,types[1].name else return 0,name end end function backpack.equip(name,side,inventory)if(peripheral.getType(side)==name)then return true end inventory=inventory or backpack.getInventory()local slot=backpack.getSlotWith(name=='workbench' and 'crafting_table' or name,inventory)if(name=='modem' and not slot)then slot=backpack.getSlotWith('peripheral',inventory)end if(slot)then turtle.select(slot)if(side=='left')then return turtle.equipLeft()else return turtle.equipRight()end end return false end function backpack.cleanup(inventory)inventory=inventory or backpack.getInventory()inventory:foreach(function(slot,item)if(linq:any(backpack.vars.trash,function(k,name)return item.name:match(name)end))then turtle.select(slot)turtle.dropUp()inventory[slot]=nil end end)return backpack.compact(inventory)end backpack.clean=backpack.cleanup function backpack.compact(inventory)local inventory=inventory or backpack.getInventory()local groups={}local transferred=false inventory:foreach(function(slot,item)groups[item.name]=groups[item.name] or{}if(item.count<64)then table.insert(groups[item.name],{slot,item.count})end end)for name,tuples in pairs(groups)do tables.sortByDescending(tuples,2)for a=1,#tuples do for b=a+1,#tuples do if(tuples[a][2]+tuples[b][2]<=64)then transferred=true turtle.select(tuples[a][1])turtle.transferTo(tuples[b][1])tuples[b][2]=tuples[b][2]+tuples[a][2] break end end end end return transferred and backpack.getInventory(inventory)or inventory end for name,func in pairs(backpack)do if(type(func)=='function' and backpack_inventory_meta.__index[name]==nil)then backpack_inventory_meta.__index[name]=function(self,...)local params={...}if(#params>0)then table.insert(params,self)return func(unpack(params))else func(self)end end end end if(console==nil)then console={}end function console.choice_impl(text,choices,add_space)local results={}for n=1,#choices do local option=choices[n] if #option+(add_space and 1 or 0)>#text and option:sub(1,#text)==text then local result=option:sub(#text+1)if add_space then table.insert(results,result.." ")else table.insert(results,result)end end end return results end function console.read(_sReplaceChar,consoletory,_fnComplete,_sDefault,_nTimeout)if _sReplaceChar~=nil and type(_sReplaceChar)~="string" then error(string.join({"bad argument #1(expected string,got ",type(_sReplaceChar),")"},''),2)end if consoletory~=nil and type(consoletory)~="table" then error(string.join({"bad argument #2(expected table,got ",type(consoletory),")"},''),2)end if _fnComplete~=nil and type(_fnComplete)~="function" then error(string.join({"bad argument #3(expected function,got ",type(_fnComplete),")"},''),2)end if _sDefault~=nil and type(_sDefault)~="string" then error(string.join({"bad argument #4(expected string,got ",type(_sDefault),")"},''),2)end if _nTimeout~=nil and type(_nTimeout)~="number" then error(string.join({"bad argument #5(expected number,got ",type(_sDefault),")"},''),2)end term.setCursorBlink(true)local sLine if type(_sDefault)=="string" then sLine=_sDefault else sLine="" end local nHistoryPos local nPos=#sLine if _sReplaceChar then _sReplaceChar=string.sub(_sReplaceChar,1,1)end local tCompletions local nCompletion local function recomplete()if _fnComplete and nPos==string.len(sLine)then tCompletions=_fnComplete(sLine)if tCompletions and #tCompletions>0 then nCompletion=1 else nCompletion=nil end else tCompletions=nil nCompletion=nil end end local function uncomplete()tCompletions=nil nCompletion=nil end local w=term.getSize()local sx=term.getCursorPos()local function redraw(_bClear)local nScroll=0 if sx+nPos>=w then nScroll=(sx+nPos)-w end local cx,cy=term.getCursorPos()term.setCursorPos(sx,cy)local sReplace=(_bClear and " ")or _sReplaceChar if sReplace then term.write(string.rep(sReplace,math.max(string.len(sLine)-nScroll,0)))else term.write(string.sub(sLine,nScroll+1))end if nCompletion then local sCompletion=tCompletions[ nCompletion ] local oldText,oldBg if not _bClear then oldText=term.getTextColor()oldBg=term.getBackgroundColor()term.setTextColor(colors.white)term.setBackgroundColor(colors.gray)end if sReplace then term.write(string.rep(sReplace,string.len(sCompletion)))else term.write(sCompletion)end if not _bClear then term.setTextColor(oldText)term.setBackgroundColor(oldBg)end end term.setCursorPos(sx+nPos-nScroll,cy)end local function clear()redraw(true)end recomplete()redraw()local function acceptCompletion()if nCompletion then clear()local sCompletion=tCompletions[ nCompletion ] sLine=sLine..sCompletion nPos=string.len(sLine)recomplete()redraw()end end local currentTimer=nil local sessionID=math.random(0,1000)function _timer()if(_nTimeout~=nil)then add(function()local ourID=math.random(0,1000)currentTimer=ourID wait(_nTimeout,function()return currentTimer~=ourID end)if(currentTimer==ourID)then queue('stopconsole',sessionID)end end)end end local charListener=on('char',function(char)clear()sLine=string.join({string.sub(sLine,1,nPos),char,string.sub(sLine,nPos+1)},'')nPos=nPos+1 recomplete()redraw()_timer()end)local pasteListener=on('paste',function(paste)clear()sLine=string.join({string.sub(sLine,1,nPos),paste,string.sub(sLine,nPos+1)},'')nPos=nPos+string.len(paste)recomplete()redraw()_timer()end)local keyListener=on('key',function(key)if key==keys.enter then if nCompletion then clear()uncomplete()redraw()end queue('stopconsole',sessionID)elseif key==keys.left then if nPos>0 then clear()nPos=nPos-1 recomplete()redraw()end elseif key==keys.right then if nPos<string.len(sLine)then clear()nPos=nPos+1 recomplete()redraw()else acceptCompletion()end elseif key==keys.up or key==keys.down then if nCompletion then clear()if key==keys.up then nCompletion=nCompletion-1 if nCompletion<1 then nCompletion=#tCompletions end elseif key==keys.down then nCompletion=nCompletion+1 if nCompletion>#tCompletions then nCompletion=1 end end redraw()elseif consoletory then clear()if key==keys.up then if nHistoryPos==nil then if #consoletory>0 then nHistoryPos=#consoletory end elseif nHistoryPos>1 then nHistoryPos=nHistoryPos-1 end else if nHistoryPos==#consoletory then nHistoryPos=nil elseif nHistoryPos~=nil then nHistoryPos=nHistoryPos+1 end end if nHistoryPos then sLine=consoletory[nHistoryPos] nPos=string.len(sLine)else sLine="" nPos=0 end uncomplete()redraw()end elseif key==keys.backspace then if nPos>0 then clear()sLine=string.join({string.sub(sLine,1,nPos-1),string.sub(sLine,nPos+1)},'')nPos=nPos-1 recomplete()redraw()end elseif key==keys.home then if nPos>0 then clear()nPos=0 recomplete()redraw()end elseif key==keys.delete then if nPos<string.len(sLine)then clear()sLine=string.join({string.sub(sLine,1,nPos),string.sub(sLine,nPos+2)},'')recomplete()redraw()end elseif key==keys["end"] then if nPos<string.len(sLine)then clear()nPos=string.len(sLine)recomplete()redraw()end elseif key==keys.tab then acceptCompletion()end _timer()end)local resizeListener=on('term_resize',function()w=term.getSize()redraw()_timer()end)local stopped=false local quitListener=on({event='stopconsole',once=true,filter=function(eSessionID)return eSessionID==sessionID end,f=function()off('char',charListener)off('paste',pasteListener)off('key',keyListener)off('term_resize',resizeListener)stopped=true if nCompletion then clear()uncomplete()redraw()end end})_timer()waitUntil(function()return stopped end)local cx,cy=term.getCursorPos()term.setCursorBlink(false)if(sLine~="")then term.setCursorPos(w+1,cy)print()end return sLine end function console.clear()term.clear()term.setCursorPos(1,1)end if(craft==nil)then craft={}end craft.recipes={['stick']={['minecraft:planks']={1,5}},['plank']={['minecraft:log']={1}},['chest']={['minecraft:planks']={1,2,3,5,7,9,10,11}},['furnace']={['minecraft:cobblestone']={1,2,3,5,7,9,10,11}},['stairs']={['minecraft:planks']={1,5,6,9,10,11}},['torch']={['minecraft:coal']={1},['minecraft:stick']={5}}}if(not _HOST:match('Minecraft 1.12'))then for recipeName,recipe in pairs(craft.recipes)do local newRecipe={}for name,slots in pairs(recipe)do if(name:match(':planks'))then newRecipe['minecraft:%w*_planks']=slots elseif(name:match(':log'))then newRecipe['minecraft:%w*_log']=slots else newRecipe[name]=slots end end craft.recipes[recipeName]=newRecipe end craft.recipes['coal_block']={['minecraft:coal']={1,2,3,5,6,7,9,10,11}}craft.recipes['raw_iron_block']={['minecraft:raw_iron']={1,2,3,5,6,7,9,10,11}}craft.recipes['raw_copper_block']={['minecraft:raw_copper']={1,2,3,5,6,7,9,10,11}}craft.recipes['lapis_block']={['minecraft:lapis_lazuli$']={1,2,3,5,6,7,9,10,11}}end function craft.getRecipe(recipeName)if(craft.recipes[recipeName]==nil)then return nil end local recipe=craft.recipes[recipeName] local requirements={}local usedSlots={}for name,slots in pairs(recipe)do table.insert(requirements,name)for k,slot in ipairs(slots)do usedSlots[slot]=name end end return recipe,requirements,usedSlots end function craft.canCraft(recipeName,inventory)local recipe=type(recipeName)=='string' and craft.getRecipe(recipeName)or recipeName if(recipe==nil)then print('Recipe not found')return false end inventory=inventory or backpack.getInventory()if(not(peripheral.getType('right')=='workbench' or backpack.getSlotWith('crafting_table',inventory)))then print('No crafting peripheral')return false end local totalCount={}local maxDistribution=64 for name,slots in pairs(recipe)do maxDistribution=math.min(maxDistribution,math.floor((backpack.getCount(name,inventory))/ #slots))end return maxDistribution>0,maxDistribution end function craft.craft(recipeName,count,inventory)count=tonumber(count)or 64 local inventory=backpack.getInventory(inventory)local recipe,requirements,usedSlots=craft.getRecipe(recipeName)if(not backpack.equip('workbench','right',inventory))then print('Craft error; peripheral not found')return false end local canCraft,maxCount=craft.canCraft(recipe,inventory)if(not canCraft)then print('Craft error; not enough ingredients')return false end count=math.min(count,maxCount)turtle.digDown()local chestSlot=backpack.getSlotWith('minecraft:chest',inventory)if(chestSlot)then turtle.select(chestSlot)turtle.placeDown()end inventory=backpack.getInventory(inventory)local needed={}local totalCount={}local copied=false for name,slots in pairs(recipe)do local itemCount,newName=backpack.getCount(name,inventory)totalCount[newName]=itemCount needed[newName]=count*#slots if(newName~=name)then recipe=copied and recipe or tables.deepCopy(recipe)copied=true recipe[newName]=slots recipe[name]=nil linq:where(requirements,function(k,v)return v==name end):take(1):remove()table.insert(requirements,newName)for k,v in pairs(usedSlots)do if(v==name)then usedSlots[k]=newName end end end end for slot,item in pairs(inventory)do if(item~=nil)then if(not linq:contains(requirements,item.name))then turtle.select(slot)turtle.dropDown()inventory[slot]=nil else if(totalCount[item.name]>needed[item.name])then local countBeforeDrop=item.count turtle.select(slot)turtle.dropDown(math.min(countBeforeDrop,totalCount[item.name]-needed[item.name]))inventory[slot]=turtle.getItemDetail(slot)totalCount[item.name]=inventory[slot] and totalCount[item.name]-(countBeforeDrop-inventory[slot].count)or totalCount[item.name]-countBeforeDrop end end end end inventory=backpack.compact(inventory)local function moveItemPartial(slotToMove,countToMove)local toMove=inventory[slotToMove] local toRemain=toMove.count-countToMove for k,slot in ipairs(recipe[toMove.name])do local item=inventory[slot] if(item and item.name~=toMove.name)then for i=16,1,-1 do if(inventory[i]==nil and usedSlots[i]==nil)then turtle.select(slot)turtle.transferTo(i)inventory[i],inventory[slot]=inventory[slot],nil item=nil break end end end if(item==nil)then turtle.select(slotToMove)turtle.transferTo(slot,math.min(count,countToMove))inventory[slotToMove]=turtle.getItemDetail(slotToMove)inventory[slot]=turtle.getItemDetail(slot)elseif(item.name==toMove.name and item.count<count)then local itemRequiresCount=count-item.count local moved=countToMove-itemRequiresCount<0 and countToMove or itemRequiresCount turtle.select(slotToMove)turtle.transferTo(slot,moved)inventory[slotToMove]=turtle.getItemDetail(slotToMove)inventory[slot]=turtle.getItemDetail(slot)end countToMove=inventory[slotToMove] and inventory[slotToMove].count-toRemain or 0 if(countToMove==0 or inventory[slotToMove].count==toRemain)then break end end end for x=1,2 do for slot=1,16 do local item=inventory[slot] if(item~=nil and recipe[item.name])then if(usedSlots[slot] and usedSlots[slot]==item.name)then if(item.count>count)then moveItemPartial(slot,item.count-count)end else moveItemPartial(slot,item.count)end end end end turtle.craft()while(turtle.suckDown())do end if(chestSlot)then turtle.digDown()end inventory=backpack.getInventory(inventory)end if(gpsi==nil)then gpsi={}end CHANNEL_GPS=65534 CHANNEL_REPLY=51933 function gpsi.trilaterate(A,B,C)local a2b=B.vPosition-A.vPosition local a2c=C.vPosition-A.vPosition if math.abs(a2b:normalize():dot(a2c:normalize()))>0.999 then return nil end local d=a2b:length()local ex=a2b:normalize()local i=ex:dot(a2c)local ey=(a2c-ex*i):normalize()local j=ey:dot(a2c)local ez=ex:cross(ey)local r1=A.nDistance local r2=B.nDistance local r3=C.nDistance local x=(r1*r1-r2*r2+d*d)/(2*d)local y=(r1*r1-r3*r3-x*x+(x-i)*(x-i)+j*j)/(2*j)local result=A.vPosition+ex*x+ey*y local zSquared=r1*r1-x*x-y*y if zSquared>0 then local z=math.sqrt(zSquared)local result1=result+ez*z local result2=result-ez*z local rounded1,rounded2=result1:round(0.01),result2:round(0.01)if rounded1.x~=rounded2.x or rounded1.y~=rounded2.y or rounded1.z~=rounded2.z then return rounded1,rounded2 else return rounded1 end end return result:round(0.01)end function gpsi.narrow(p1,p2,fix)local dist1=math.abs((p1-fix.vPosition):length()-fix.nDistance)local dist2=math.abs((p2-fix.vPosition):length()-fix.nDistance)if math.abs(dist1-dist2)<0.01 then return p1,p2 elseif dist1<dist2 then return p1:round(0.01)else return p2:round(0.01)end end function gpsi.locate(_nTimeout,_bDebug)method.expect(1,_nTimeout,"number","nil")method.expect(2,_bDebug,"boolean","nil")if commands then return commands.getBlockPosition()end local sModemSide=nil for _,sSide in ipairs(rs.getSides())do if peripheral.getType(sSide)=="modem" and peripheral.call(sSide,"isWireless")then sModemSide=sSide break end end if sModemSide==nil then if _bDebug then log.logWarning("No wireless modem attached")end return nil end if _bDebug then log.logVerbose("Finding position...")end local modem=peripheral.wrap(sModemSide)local bCloseChannel=false if not modem.isOpen(CHANNEL_REPLY)then modem.open(CHANNEL_REPLY)bCloseChannel=true end modem.transmit(CHANNEL_GPS,CHANNEL_REPLY,"PING")local tFixes={}local pos1,pos2=nil,nil local done=false local onModemMessage=function(sSide,sChannel,sReplyChannel,tMessage,nDistance)if sSide==sModemSide and sChannel==CHANNEL_REPLY and sReplyChannel==CHANNEL_GPS and nDistance then if type(tMessage)=="table" and #tMessage==3 and tonumber(tMessage[1])and tonumber(tMessage[2])and tonumber(tMessage[3])then local tFix={vPosition=vector.new(tMessage[1],tMessage[2],tMessage[3]),nDistance=nDistance}if _bDebug then log.logVerbose(tFix.nDistance," metres from ",tostring(tFix.vPosition))end if tFix.nDistance==0 then pos1,pos2=tFix.vPosition,nil else table.insert(tFixes,tFix)if #tFixes>=3 then if not pos1 then pos1,pos2=gpsi.trilaterate(tFixes[1],tFixes[2],tFixes[#tFixes])else pos1,pos2=gpsi.narrow(pos1,pos2,tFixes[#tFixes])end end end if pos1 and not pos2 then done=true end end end end on('modem_message',onModemMessage)wait(_nTimeout or 2,function()return done end)off('modem_message',onModemMessage)if bCloseChannel then modem.close(CHANNEL_REPLY)end if pos1 and pos2 then if _bDebug then log.logVerbose("Ambiguous position")log.logVerbose("Could be ",pos1.x,",",pos1.y,",",pos1.z," or ",pos2.x,",",pos2.y,",",pos2.z)end return nil elseif pos1 then if _bDebug then log.logVerbose("Position is ",pos1.x,",",pos1.y,",",pos1.z)end return Location:new(math.floor(pos1.x),math.floor(pos1.y),math.floor(pos1.z))else if _bDebug then log.logVerbose("Could not determine position")end return nil end end if(twrap==nil)then twrap={}end function twrap.wrapRepeat(action,times)times=times or 1 if(times>0)then for i=2,times do action()end return action()end end function twrap.whileTrue(action)local result=action()while(result)do result=action()end return result end function twrap.right(i)i=(i or 1)% 4 if(i==1)then return turtle.turnRight()elseif(i==2)then return twrap.wrapRepeat(turtle.turnRight,i)elseif(i==3)then return turtle.turnLeft()end end function twrap.left(i)i=(i or 1)% 4 if(i==1)then return turtle.turnLeft()elseif(i==2)then return twrap.wrapRepeat(turtle.turnLeft,i)elseif(i==3)then return turtle.turnRight()end end twrap.turnRight=twrap.right twrap.turnLeft=twrap.left function twrap.turnAround()return twrap.right(2)end function twrap.forward(i)return twrap.wrapRepeat(turtle.forward,i)end function twrap.back(i)return twrap.wrapRepeat(turtle.back,i)end function twrap.up(i)return twrap.wrapRepeat(turtle.up,i)end function twrap.down(i)return twrap.wrapRepeat(turtle.down,i)end function twrap.dig()return twrap.whileTrue(turtle.dig)end function twrap.digUp()return twrap.whileTrue(turtle.digUp)end function twrap.digDown()return twrap.whileTrue(turtle.digDown)end if(turtle~=nil)then for k,v in pairs(turtle)do if(k~='native' and twrap[k]==nil)then twrap[k]=v end end end if(network==nil)then network={}end network.addr={}network.senderID=os and os.getComputerID()or 0 network.protocol="BIFORMATION.PLAIN.V2" network.queueUpdates=true network.hasModem=peripheral.find('modem')~=nil add(function()on({event='peripheral',filter=function(side)return peripheral.getType(side)=='modem' end,once=false,f=function()network.hasModem=peripheral.find('modem')~=nil if(network.hasModem)then network.open()end end})on({event='peripheral_detach',once=false,f=function()network.hasModem=peripheral.find('modem')~=nil end})end)rednet.CHANNEL_BROADCAST=51932 local cAddress=class({constructor=function(self,name,id)self.name=name self.id=id self.dropped=0 end})function network.getIds(name)return network.hasAddress(name)and linq:select(network.addr[name].points,function(key,value)return value.id end):get()or{}end function network.getAddresses()return network.addr end function network.hasAddress(name)return network.addr[name]~=nil and linq:any(network.addr[name].points)end function network.printAddresses()for typ,adr in pairs(network.addr)do log.logInformation(typ,':',string.join(linq:select(adr.points,function(key,value)return value.id end):getSorted(),','))end end function network.getCurrentAddress(name)if(not network.hasAddress(name))then return nil end local address=network.addr[name] address.pointer=((address.pointer-1)% #address.points)+1 return address.points[address.pointer] end function network.getAddress(name)if(not network.hasAddress(name))then return nil end network.addr[name].pointer=(network.addr[name].pointer % #network.addr[name].points)+1 return network.getCurrentAddress(name)end function network.addAddress(name,id)if(not network.hasAddress(name))then network.addr[name]={points={},pointer=0}end if(not linq:where(network.addr[name].points,function(k,v)return v.id==id end):any())then table.insert(network.addr[name].points,cAddress:new(name,id))if(network.queueUpdates)then queue('network_address_added',{name=name,id=id})end end end function network.removeAddress(name,id)if(not network.hasAddress(name))then return nil end linq:where(network.addr[name].points,function(k,v)return v.id==id end):take(1):remove()if(network.queueUpdates)then queue('network_address_removed',{name=name,id=id,anyLeft=network.hasAddress(name)})end end function network.clearAddress(name)if(not network.hasAddress(name))then return nil end if(network.queueUpdates)then local addressIds=linq:select(network.addr[name].points,function(key,value,i)return value.id end):get()for k,id in ipairs(addressIds)do queue('network_address_removed',{name=name,id=id,anyLeft=false})end end network.addr[name]=nil end function network.clearAddresses()if(network.queueUpdates)then for name,addr in pairs(network.addr)do local addressIds=linq:select(addr.points,function(key,value,i)return value.id end):get()for k,id in ipairs(addressIds)do queue('network_address_removed',{name=name,id=id,anyLeft=false})end end end network.addr={}end function network.targetToAddress(target)local address if(type(target)=='table' and cAddress:is(target))then address=target elseif(type(target)=='string')then address=network.getAddress(target)end return address~=nil,address end function network.markAddressDropped(address)if(not cAddress:is(address))then return end address.dropped=address.dropped+1 if(address.dropped>2)then network.removeAddress(address.name,address.id)end end function network.markAddressReceived(address)if(not cAddress:is(address))then return end address.dropped=0 end function network.onNetworkAddressAdded(name,callback)on({event='network_address_added',filter=function(obj)return obj.name==name end,once=false,f=callback})if(network.hasAddress(name))then add(function()callback()end)end end function network.onNetworkAddressRemoved(name,callback)on({event='network_address_removed',filter=function(obj)return obj.name==name end,once=false,f=callback})if(not network.hasAddress(name))then add(function()callback({name=name,id=-1,anyLeft=false})end)end end function network.open(side)if(not network.hasModem)then return false end if(rednet.isOpen())then return true end if(side~=nil)then pcall(rednet.open,side)else local i=1 while(not rednet.isOpen()and i<=#var.sides)do pcall(rednet.open,var.sides[i])i=i+1 end end local isOpen=rednet.isOpen()if(isOpen)then log.logVerbose("Connected to network")else log.logWarning("Failed to connect to network")end return isOpen end function network.receive(timeout,filter,identifier)local receiveFilter=function(sender,message,protocol)return protocol==network.protocol and(filter and filter(sender,message,protocol))end local senderId,message,protocol if(timeout==nil)then senderId,message,protocol=coroutine.yield('rednet_message',receiveFilter)else local ourID=os.startTimer(timeout)local response=nil local handler=on({event='rednet_message',filter=receiveFilter,once=true,f=function(fSenderId,FMessage,fProtocol)response={fSenderId,FMessage,fProtocol or '_'}queue('timer',ourID)end})coroutine.yield('timer',function(id)return id==ourID end)if(response)then os.cancelTimer(ourID)senderId,message,protocol=unpack(response)else off('rednet_message',handler)end end if(senderId~=nil)then log.logVerbose("Received message from #",senderId,' for ',identifier or message.url)return message,senderId else log.logVerbose("Received no ",identifier or(message and message.url),"message within ",(timeout or-1)," seconds")return nil,nil end end function network.receiveMany(callback,timeout,filter,identifier)identifier=identifier or '' local eventHandler=on({event='rednet_message',filter=function(sender,message,protocol)return protocol==network.protocol and(filter==nil or filter(sender,message,protocol))end,once=false,f=function(sender,message,protocol)callback(message,sender)end})if(timeout~=nil)then wait(timeout)log.logVerbose("Network ",identifier,"receiver timed out")off('rednet_message',eventHandler)end end function network.broadcast(message)method.expect(1,message,'table')if(not network.open())then return nil end message.type=message.type or 'REQUEST' message.headers=message.headers or{}message.headers.sender=network.senderID message.headers.corID=message.headers.corID or math.random(0,9999)log.logVerbose("Broadcasting ",(message.url or "")," to network")return rednet.broadcast(message,network.protocol)end function network.send(message,receiver)method.expect(1,message,'table')method.expect(2,receiver,'number')if(not network.open())then return nil end message.headers=message.headers or{}message.headers.sender=network.senderID message.headers.corID=message.headers.corID or math.random(0,9999)log.logVerbose("Send to #",receiver,' at ',message.url)return rednet.send(receiver,message,network.protocol)end function network.respond(request,response)network.send({type='RESPONSE',url=request.url,method=request.method,headers={request=request,corID=request.headers.corID},body=response},request.headers.sender)end function network.get(...)return network._send('GET',...)end function network.post(...)return network._send('POST',...)end function network.put(...)return network._send('PUT',...)end function network._send(method,target,url,headers,body,timeout)local ok,address=network.targetToAddress(target)if(ok)then target=address.id end if(type(target)~='number')then log.logError("network.targetToAddress failed",type(target))return false end local message={type='REQUEST',method=method,url=url,headers=headers or{},body=body or{}}network.send(message,target)local responseMessage,responseSender=network.receive(timeout or 10,function(sender,received,protocol)return received.type=='RESPONSE' and received.headers.corID==message.headers.corID end)return responseMessage end if(polly==nil)then polly={}end polly.retry=function(funcToRetry,funcStopCondition,delay)funcToRetry()while(not funcStopCondition())do wait(delay)funcToRetry()end end polly.retryWhileNil=function(funcToRetry,delay)local response=funcToRetry()local i=0 local increase=5 local maxWait=60 delay=delay or increase while(response==nil)do i=i+1 wait(delay)response=funcToRetry()if(delay+i*increase<maxWait)then delay=delay+i*increase end end return response end if(web==nil)then web={}end function web.printUsage()print("Usage:")print("web.getToFile<url><filename>")end function web.request(sUrl)http.request(sUrl,nil,nil,false)local fired,ok=false,false local response,err='','' local fOk=function(fUrl,fHandle)fired=true ok=true response=fHandle end local fFail=function(fUrl,fErr,fHandle)fired=true ok=false response=fHandle err=fErr end once{event="http_success",f=fOk,filter=function(fUrl)return fUrl==sUrl end}once{event="http_failure",f=fFail,filter=function(fUrl)return fUrl==sUrl end}waitUntil(function()return fired end)off("http_success",fOk)off("http_failure",fFail)return ok,response,err end function web.get(sUrl)log.logVerbose("Connecting to ",sUrl,"...")local fired,ok=false,false local err,response='',nil local checkF=once{event="http_check",f=function(fUrl,fOk,fErr)fired=true ok=fOk err=fErr end,filter=function(fUrl)return fUrl==sUrl end}if(not http.checkURLAsync(sUrl))then log.logError('web.get ',sUrl,' is invalid')off("http_check",checkF)return nil end waitUntil(function()return fired end)if not ok then log.logError('web.get ',sUrl,' not OK')if err then printError(err)end return nil end ok,response,err=web.request(sUrl)if not ok then log.logError('web.get ',sUrl,' did not respond')if err then printError(err)end return nil end if not response then return nil end local sResponse=response.readAll()response.close()return sResponse end function web.getToFile(...)local tArgs={...}if #tArgs<2 then web.printUsage()return end if not http then printError("wget requires http API")printError("Set http_enable to true in ComputerCraft.cfg")return end local sUrl=tArgs[1] local sFile=tArgs[2] local sPath=shell.resolve(sFile)local res=web.get(sUrl)if res then files.write(sPath,res)log.logVerbose("Downloaded as ",sFile)end return res end if(waiter==nil)then waiter={}end waiter.index=1 waiter.options={enabled=true,console=true,indicators={'|','/','-','\\'},timeout=0.2}function waiter.setOption(name,value)waiter.options[name]=value end function waiter.serve(command,...)local response local quit=false local args={...}local waitFunc=add(function()response={try(function()return command(unpack(args))end)}quit=true end)waiter.wait(function()return quit end)off(waitFunc)return unpack(response or{})end function waiter.wait(waitFor)if(not waiter.options.enabled)then if(waitFor==nil)then return elseif(type(waitFor)=='function')then waitUntil(waitFor)elseif(type(waitFor)=='number')then wait(waitFor)end return end local timeout=waiter.options.timeout local indicators=waiter.options.indicators local quit=false if(waitFor~=nil)then if(type(waitFor)=='function' and waitFor())then return end add(function()if(type(waitFor)=='number')then wait(waitFor,function()return quit end)else waitUntil(function()return quit or waitFor()end)end quit=true end)end local waitQuitCommands={'q','quit'}local x,y=term.getCursorPos()while(not quit)do term.setCursorPos(1,y)term.clearLine()term.setCursorPos(1,y)term.write(indicators[(waiter.index % #indicators)+1])term.setCursorPos(1,y+1)if(waiter.options.console)then local qinput=console.read(nil,nil,function(text)choice_complete(text,waitQuitCommands)end,nil,timeout)quit=quit or linq:contains(waitQuitCommands,qinput or '')else wait(timeout)end waiter.index=waiter.index+1 end term.setCursorPos(1,y)term.clearLine()waiter.index=waiter.index % #indicators end function updatePosition(newLocation,updateFacing)local previousLocation=state.spec.location newLocation=newLocation or gpsi.locate()if(newLocation==nil)then error('updatePosition; newLocation is nil')end state.spec.location=newLocation if(previousLocation==nil or not previousLocation.isLocation)then return 0 end local distance=previousLocation:distance2d(newLocation)if(distance>0 and updateFacing~=false)then local newFacing=positions.calcFacingStartStop(previousLocation,newLocation)if(newFacing~='unknown' and state.spec.facing~=newFacing)then state.spec.facing=newFacing end end return distance end add(function()waitUntil(function()return state~=nil and state.status~='podinitializing' end)if(not state.config.location.autoUpdate)then log.logInformation('location autoUpdate is disabled')return end local shortestWait=0.5 local longestWait=5 local waitIncrease=0.5 local currentWait=1 while(true)do local previousLocation=state.spec.location if(previousLocation==nil or not previousLocation.isLocation)then previousLocation=nil end local newLocation=gpsi.locate()local distance=updatePosition(newLocation,state.config.location.autoUpdate)if(previousLocation~=nil and newLocation~=nil)then local distanceMod=distance / currentWait local waitDiff=0 if(distanceMod==0 or distanceMod>5)then waitDiff=1 elseif(distanceMod>0 and distanceMod<=2)then waitDiff=-2 end currentWait=math.max(math.min(currentWait+waitIncrease*waitDiff,longestWait),shortestWait)end wait(currentWait)end end)function receiveRequest(path,actionFunc,timeout)return receive(path,actionFunc,true,timeout)end function receiveResponse(path,actionFunc,timeout)return receive(path,actionFunc,false,timeout)end function _doesPathMatchPattern(path,pathPattern)local pathParts=string.split(path,'/')pathPattern=type(pathPattern)=='table' and pathPattern or string.split(pathPattern,'/')if(#pathParts~=#pathPattern)then return false end for k,v in ipairs(pathParts)do if(pathPattern[k]~='*' and v~=pathPattern[k])then return false end end return true end function receive(path,actionFunc,isRequest,timeout)local filterType=(isRequest or nil==isRequest)and 'REQUEST' or 'RESPONSE' local pathPattern=type(path)=='table' and path or string.split(path,'/')local callbackIntermediary=function(message,sender)actionFunc(message,string.split(message.url,'/'))end local filterFunction=function(sender,message,protocol)return message.type==filterType and _doesPathMatchPattern(message.url,pathPattern)end add(function()waitUntil(function()return state==nil or state.status~='podinitializing' end)network.receiveMany(callbackIntermediary,timeout,filterFunction)end)end if(stateH==nil)then stateH={}end stateH.id=os.getComputerID()state=state or{}stateH.init=function(params)params=params or{}state={id=stateH.id,sid=tostring(stateH.id),name=tostring(stateH.id),status=params.status or 'pending',types=params.types or{},elegibleTypes=params.elegibleTypes or{},spec={location=nil,facing='unknown',action=nil,network=network.addr},config={location={autoUpdate=params.autoUpdateLocation or false}},events={},data={}}return state end stateH.addType=function(newType)if(not linq:contains(state.types,newType))then table.insert(state.types,newType)queue('state_type_added',newType)end end stateH.removeType=function(existingType)if(linq:contains(state.types,existingType))then linq:where(state.types,function(k,v)return v==existingType end):remove()queue('state_type_removed',existingType)end end function stateH.onStateTypeAdded(name,callback)on({event='state_type_added',filter=function(t)return t==name end,once=false,f=callback})if(linq:contains(state.types,name))then add(function()callback()end)end end stateH.save=function()files.writeJson('state.json',state)end stateH.load=function()state=files.readJson('state.json')return state end if(chat==nil)then chat={}end chat.commands={}chat.cmd=chat.commands chat.quitCommands={'exit','quit','stop'}chat.interactiveCommands={}chat.cmd['repeat']=function(count,func,...)if(chat.commands[func]==nil)then log.logWarning('no action specified')return end if(tonumber(count)==nil)then log.logWarning('number expected')return end for i=1,count do chat.commands[func](...)end end chat.actualCommands=nil chat.completeCommands=nil function choice_complete(text)if(#text==0)then return{}end return console.choice_impl(text,chat.completeCommands,false)end function chat.add(name,func,opts)if(not opts)then chat.cmd[name]=func else setmetatable(opts,{__call=func})chat.cmd[name]=opts end end chat.history={}chat.maxHistory=20 function chat.run()local history=chat.history local commands=chat.commands if(chat.actualCommands==nil)then chat.actualCommands=linq:select(chat.commands,function(k,v)return k end):join(chat.quitCommands):get()end chat.completeCommands=linq:join(chat.actualCommands,history):get()local text=console.read(nil,history,choice_complete)if(text=='')then return true end if(linq:contains(chat.quitCommands,text))then return false end if(history[#history]~=text)then table.insert(history,text)if(#history>chat.maxHistory)then table.remove(history,1)end end local textParts=string.split(text,' ')local command=table.remove(textParts,1)if(commands[command])then if(linq:contains(chat.interactiveCommands,command))then commands[command](unpack(textParts))else waiter.serve(commands[command],unpack(textParts))end else log.logWarning('Unknown command ',text)end return true end if(drone==nil)then drone={}end for k,v in pairs(twrap)do if(drone[k]==nil)then drone[k]=v end end function drone.determineFacing()updatePosition()function tryFacing()local fuel=drone.getFuelLevel()if(fuel==0)then return 'unknown' end if(drone.forward()and fuel~=drone.getFuelLevel())then updatePosition()return state.spec.facing elseif(drone.back()and fuel~=drone.getFuelLevel())then updatePosition()state.spec.facing=positions.reverseDirection(state.spec.facing)return state.spec.facing elseif(drone.left()and drone.forward()and fuel~=drone.getFuelLevel())then updatePosition()return state.spec.facing elseif(drone.back()and fuel~=drone.getFuelLevel())then updatePosition()state.spec.facing=positions.reverseDirection(state.spec.facing)return state.spec.facing end return 'unknown' end local facing=tryFacing()if(facing=='unknown')then drone.up()facing=tryFacing()end if(facing=='unknown')then drone.down(2)facing=tryFacing()end return facing end function drone.faceTo(direction)local currentIndex=linq:indexOf(var.directions,state.spec.facing)local targetIndex=linq:indexOf(var.directions,direction)if(currentIndex<0 or targetIndex<0)then print('could not determine index')return nil end local diff=targetIndex-currentIndex if(math.abs(diff)==2)then drone.left(2)elseif(diff>0)then drone.right(diff)elseif(diff<0)then drone.left(math.abs(diff))end state.spec.facing=direction end function drone.shortestTurn(from,to)local tSplit=string.split(to,'-')if(#tSplit<2)then return to end local t0=linq:indexOf(var.directions,from)local t1=math.abs(linq:indexOf(var.directions,tSplit[1])-t0)t1=t1<3 and t1 or t1 % 2 local t2=math.abs(linq:indexOf(var.directions,tSplit[2])-t0)t2=t2<3 and t2 or t2 % 2 return t1<t2 and tSplit[1] or tSplit[2] end function drone.moveTo(target,tries)tries=tries or 1 if(tries>3)then state.spec.action=nil return end state.spec.action={type='moving',target=target,tries=tries}if(type(target)~='table' or not target.isLocation)then error('moveTo; target not a location')end local current=gpsi.locate()local diff=target-current function mX()if(diff.x<0)then drone.faceTo('west')drone.forward(diff.x*-1)elseif(diff.x>0)then drone.faceTo('east')drone.forward(diff.x)end end function mY()if(diff.y<0)then drone.faceTo('north')drone.forward(diff.y*-1)elseif(diff.y>0)then drone.faceTo('south')drone.forward(diff.y)end end local targetFacing,targetFacingExpanded=positions.calcFacingStartStop(current,target)local shouldStartWith=drone.shortestTurn(state.spec.facing,targetFacingExpanded)if(linq:indexOf(var.directions,shouldStartWith)% 2==0)then mX()mY()else mY()mX()end if(diff.z>0)then drone.up(diff.z)elseif(diff.z<0)then drone.down(diff.z*-1)end if(target~=gpsi.locate())then drone.moveTo(target,tries+1)end state.spec.location=gpsi.locate()state.spec.action=nil end drone.moveOptions={u=drone.up,d=drone.down,b=drone.back,l=drone.left,r=drone.right,f=drone.forward}drone.digOptions={u=drone.digUp,d=drone.digDown,f=drone.dig}function drone.go(actions)if(type(actions)~='string')then return end for command,count in actions:gmatch("([udblrf])(%d*)")do drone.moveOptions[command](count and tonumber(count))end end function drone.goDig(actions)if(type(actions)~='string')then return end for command,count in actions:gmatch("([udblrf])(%d*)")do if(drone.digOptions[command])then drone.digOptions[command]()end drone.moveOptions[command](count and tonumber(count))end end if(election==nil)then election={}end election.elections={}function election.startElection(electionType)if(linq:contains(election.elections,electionType))then return false end table.insert(election.elections,electionType)local elected=false local isElegible=linq:contains(state.elegibleTypes,electionType)if(not isElegible)then network.broadcast({type='REQUEST',method='GET',url='/election/'..electionType,body={id=-1,electionType=electionType}})else local candidates=election.lookupCandidates(electionType)if(not linq:any(candidates))then log.logVerbose('No response on election ',electionType,',electing self')if(not linq:contains(state.types,electionType))then stateH.addType(electionType)end network.addAddress(electionType,state.id)network.broadcast({type='REQUEST',method='POST',url='/election/'..electionType..'/elected',body={id=state.id,electionType=electionType}})elected=true queue('elected',{self=true,electionType=electionType,id=state.id})end end linq:where(election.elections,electionType):take(1):remove()return elected end function election.lookupCandidates(electionType)local responses={}local electionUrl='/election/'..electionType receiveResponse(electionUrl,function(okResponse)if(okResponse==nil or okResponse.body.id==nil)then return end table.insert(responses,okResponse.body.id)end,2)network.broadcast({type='REQUEST',method='GET',url=electionUrl,body={id=state.id,electionType=electionType}})wait(2,function()return #responses>0 end)return responses end function election.whenElected(electionType,callbackFunc)add(function()if(linq:contains(state.types,electionType))then callbackFunc()end return on{event="elected",filter=function(election)return election.electionType==electionType and election.self end,f=callbackFunc}end)end receiveRequest('/election/*',function(request,urlParts)local isElegible=linq:contains(state.elegibleTypes,request.body.electionType)if(isElegible and request.body.id<state.id)then network.respond(request,{id=state.id})election.startElection(request.body.electionType)end end)receiveRequest('/election/*/elected',function(request,urlParts)network.clearAddress(request.body.electionType)network.addAddress(request.body.electionType,request.body.id)linq:where(election.elections,request.body.electionType):take(1):remove()if(request.body.id~=state.id)then stateH.removeType(request.body.electionType)end queue('elected',{self=false,electionType=request.body.electionType,id=request.body.id})log.logVerbose(request.body.electionType,' elected: ',request.body.id)end)if(networkHandling==nil)then networkHandling={}end networkHandling.discovery={inProgress=false,lastExecuted=nil,refreshInterval=60}networkHandling.updateHandlerRunning=false function networkHandling.discoveryLoop()if(networkHandling.updateHandlerRunning)then return end networkHandling.updateHandlerRunning=true while(linq:contains(state.types,'network'))do wait(networkHandling.discovery.refreshInterval)networkHandling.startNetworkDiscovery()end networkHandling.updateHandlerRunning=false end add(function()for k,typeName in ipairs(state.types)do network.addAddress(typeName,state.id)end network.onNetworkAddressRemoved('network',function(eventObj)if(network.hasModem and not eventObj.anyLeft)then if(not networkHandling.lookup('network'))then election.startElection('network')end end end)stateH.onStateTypeAdded('network',function()networkHandling.discoveryLoop()end)wait(math.random(1,2))if(network.hasModem and not getNetworkMap())then wait(3)networkHandling.startNetworkDiscovery()end state.status='running' end)function networkHandling.startNetworkDiscovery()log.logVerbose('Start network discovery')if(linq:contains(state.types,'network'))then log.logVerbose('I\'m already network')networkHandling.buildNetworkMap()log.logVerbose('Network discovery done')return end local success=getNetworkMap()if(not success)then election.startElection('network')wait(5,function()return network.hasAddress('network')end)networkHandling.startNetworkDiscovery()end log.logVerbose('network leaders:',string.join(network.getIds('network'),','))log.logVerbose('Network discovery done')end function getNetworkMap()log.logVerbose('getNetworkMap')if(linq:contains(state.types,'network'))then networkHandling.buildNetworkMap()return true end local retries=0 local networkHost=network.getCurrentAddress('network')or networkHandling.lookup('network')while(networkHost~=nil and networkHandling.testPodAlive('network')and retries<5)do retries=retries+1 local networkMapRequest=network.get('network','/network')if(networkMapRequest~=nil and networkMapRequest.body~=nil)then log.logVerbose('Updated network map')networkHandling.updateNetwork(networkMapRequest.body)return true end log.logWarning('Got empty network map,retry in 1 second')network.markAddressDropped(networkHost)wait(1)networkHost=network.getCurrentAddress('network')end return false end function networkHandling.buildNetworkMap()log.logVerbose('Build network map')networkHandling.discovery.inProgress=true local timeout=2 local addressMap={pod={state.id}}for k,typ in ipairs(state.types)do addressMap[typ]=addressMap[typ] or{}table.insert(addressMap[typ],state.id)end receiveResponse('/network/ping',function(response)local newAddr=response.body if(newAddr==nil or type(newAddr)~='table')then return end if(not linq:contains(addressMap.pod,newAddr.id))then table.insert(addressMap.pod,newAddr.id)for k,typ in ipairs(newAddr.types)do addressMap[typ]=addressMap[typ] or{}table.insert(addressMap[typ],newAddr.id)end end end,timeout)network.broadcast({type='REQUEST',method='GET',url='/network/ping'})wait(timeout)local anyChange=false local seenTypes={}for typ,ids in pairs(addressMap)do table.insert(seenTypes,typ)local existingIds=network.getIds(typ)for k,existingId in ipairs(existingIds)do if(not linq:contains(ids,existingId))then anyChange=true network.removeAddress(typ,existingId)end end for k,newId in ipairs(ids)do if(not linq:contains(existingIds,newId))then anyChange=true network.addAddress(typ,newId)end end end for typ in pairs(network.getAddresses())do if(not linq:contains(seenTypes,typ))then network.clearAddress(typ)end end if(anyChange)then network.broadcast({type='REQUEST',method='POST',url='/network/update',body=network.getAddresses()})end local anyDuplicateNetworkLeaders=linq:any(addressMap.network or{},function(k,id)return id~=state.id end)if(anyDuplicateNetworkLeaders)then election.startElection('network')end networkHandling.discovery.inProgress=false end function networkHandling.updateNetwork(map)network.addr=map state.spec.network=network.addr end function networkHandling.lookup(name)if(not network.hasModem)then return nil end if(network.hasAddress(name))then return network.getAddress(name)end local responses={}local received=false local url='/network/lookup/'..name receiveResponse(url,function(response)response=response.body if(response==nil or linq:contains(responses,response))then return end table.insert(responses,response)received=true end,2)network.broadcast({type='REQUEST',method='GET',url=url})wait(2,function()return received end)for k,response in ipairs(responses)do if(response==state.id or networkHandling.testPodAlive(response))then network.addAddress(name,response)if(response==state.id and not linq:contains(state.types,name))then stateH.addType(name)end end end return network.getAddress(name)end function networkHandling.testPodAlive(address)if(address==nil)then return false end local health=network.get(address,'/health',nil,nil,2)return health~=nil end receiveRequest('/health',function(request)network.respond(request,true)end)receiveRequest('/network',function(request)local condition=function()return not networkHandling.discovery.inProgress end wait(5,condition)if(condition())then network.respond(request,network.getAddresses())end end)receiveRequest('/network/update',function(request)networkHandling.updateNetwork(request.body)end)receiveRequest('/network/lookup/*',function(request,urlParts)waitUntil(function()return not networkHandling.discovery.inProgress end)local r=network.getAddress(urlParts[3])if(r~=nil and r.id~=nil)then network.respond(request,r.id)end end)receiveRequest('/network/ping',function(request)network.respond(request,{types=state.types,id=state.id})debounce('/network/ping',function()election.startElection('network')end,networkHandling.discovery.refreshInterval*3+1)end)election.whenElected('network',function()networkHandling.buildNetworkMap()end)if(cachehandling==nil)then cachehandling={}end cachehandling.updateChecked=false function updateFileCache()if(not network.hasAddress('cache'))then return end local url='/luacache/'..thisFile local responseFile=network.get('cache',url)if(responseFile==nil)then error('Got empty response on ',url)end log.logVerbose('Found ',thisFile,' file from cache')files.write('startup.lua',responseFile.body.content)state.data.cacheupdate=os.time('local')stateH.save()log.logWarning('Rebooting for cache...')wait(1)os.reboot()end add(function()wait(30,function()return cachehandling.updateChecked or(network.hasAddress('cache')and not linq:contains(state.types,'cache'))end)if(not(network.hasAddress('cache')and not linq:contains(state.types,'cache')))then return end local lastUpdated=state.data.cacheupdate or 0 local url='/luacache/'..thisFile..'/lastChecked' local response=network.get('cache',url)if(response~=nil)then local diff=response.body-lastUpdated if(diff>0.002)then wait(2)updateFileCache()end else log.logVerbose('Cache server did not respond to ',url)end end)receiveRequest('/luacache',function(message,urlParts)if(linq:contains(state.types,'cache'))then return end log.logInfo('Received message ',message.url,' from ',message.headers.sender)if(not network.hasAddress('cache'))then network.addAddress('cache',message.headers.sender)end if(linq:contains(message.body,thisFile))then updateFileCache()end log.logVerbose('Message handling ',message.url,' from ',message.headers.sender,' done')end)add(function()if(not linq:contains(state.elegibleTypes,'cache'))then return nil end cachehandling.indexFile='https://raw.githubusercontent.com/latens/bug-free-octo-couscous-index/refs/heads/main/index.prod.json' cachehandling.cacheConfigFile='cache.json' cachehandling.refreshInterval=60 cachehandling.cache=files.readJson(cachehandling.cacheConfigFile)or{files={},lastChecked=0,latestChanges={},}function cachehandling.updateCache()local now=os.time('local')log.logVerbose('Update cache ',now)local latestChanges={}local index=polly.retryWhileNil(function()return web.get(cachehandling.indexFile)end)index=textutils.unserialiseJSON(index)for _,file in ipairs(index.files or index)do if(cachehandling.cache.files[file.name]==nil)then cachehandling.cache.files[file.name]={diskPath='cache/'..file.name,changeID=file.changeID-1,name=file.name}end local cachedFile=cachehandling.cache.files[file.name] if(cachedFile.changeID<file.changeID)then table.insert(latestChanges,cachedFile.name)cachedFile.changeID=file.changeID web.getToFile((index.baseUrl or 'https://raw.githubusercontent.com/latens/bug-free-octo-couscous-index/refs/heads/main/files/prod/')..file.name,cachedFile.diskPath)cachedFile.updatedAt=now end end cachehandling.cache.latestChanges=latestChanges cachehandling.cache.lastChecked=now files.writeJson(cachehandling.cacheConfigFile,cachehandling.cache)end function cachehandling.getCachedFileContent(name)return files.read(cachehandling.cache.files[name].diskPath)end function cachehandling.getCachedContent()local response={}for name,opts in pairs(cachehandling.cache.files)do table.insert(response,{name=name,content=cachehandling.getCachedFileContent(name)})end return response end network.onNetworkAddressRemoved('cache',function(eventObj)if(not eventObj.anyLeft)then if(not networkHandling.lookup('cache'))then election.startElection('cache')end end end)cachehandling.updateHandlerRunning=false function cachehandling.cacheUpdateHandler()if(cachehandling.updateHandlerRunning)then return end cachehandling.updateHandlerRunning=true wait(2)try(function()repeat cachehandling.updateCache()local changes=cachehandling.cache.latestChanges if(linq:any(changes))then if(network.hasModem)then log.logInformation('Broadcasting file updates ')network.broadcast({type='REQUEST',method='POST',url='/luacache',body=changes})wait(5)else log.logInformation('Update found')wait(1)end if(linq:contains(changes,thisFile))then local content=files.read('cache/'..thisFile)files.write('startup.lua',content)log.logWarning('Rebooting...')os.reboot()end end cachehandling.cache.latestChanges={}wait(cachehandling.refreshInterval)until(not linq:contains(state.types,'cache'))end)cachehandling.updateHandlerRunning=false end stateH.onStateTypeAdded('cache',function()cachehandling.cacheUpdateHandler()end)receiveRequest('/luacache/*/lastChecked',function(request,urlParts)local fileName=urlParts[2] network.respond(request,cachehandling.cache.files[fileName].updatedAt)end)receiveRequest('/luacache',function(request)network.respond(request,cachehandling.getCachedContent())end)receiveRequest('/luacache/*',function(request,urlParts)local fileName=urlParts[2] local content=cachehandling.getCachedFileContent(fileName)network.respond(request,{name=fileName,content=content})end)end)thisFile='allmight.lua' print('v1.3')if(not stateH.load())then stateH.init({types={'allmight'},elegibleTypes={'allmight','cache','network'}})end table.insert(chat.interactiveCommands,'clear')function chat.cmd.climb(sub)if(sub=='stairs')then local ok,inspect=turtle.inspect()while(ok and inspect.name:match('stairs'))do drone.go('uf')ok,inspect=turtle.inspect()end end end function chat.cmd.inspect()local ok,i=turtle.inspect()if(ok)then print(textutils.serialiseJSON(i))end end function chat.cmd.details()local data=turtle.getItemDetail()if(data)then print(textutils.serialiseJSON(data))end end function chat.cmd.equip(slot,side)if(tonumber(slot))then turtle.select(tonumber(slot))else side=slot end if(not side or side=='left')then turtle.equipLeft()else turtle.equipRight()end end function chat.cmd.suck(sub)if(sub==nil)then while(turtle.suck())do end elseif(sub=='up' or sub=='u')then while(turtle.suckUp())do end elseif(sub=='down' or sub=='d')then while(turtle.suckDown())do end end end function chat.cmd.place(sub,count)if(type(sub)=='number')then turtle.select(sub)turtle.place()elseif(type(sub)=='string')then if(type(count)=='number')then turtle.select(count)end if(sub=='up' or sub=='u')then turtle.placeUp()elseif(sub=='down' or sub=='d')then turtle.placeDown()else turtle.place()end else turtle.place()end end function chat.cmd.drop(sub,count)if(type(sub)=='number')then turtle.select(sub)turtle.drop()elseif(type(sub)=='string')then if(type(count)=='number')then turtle.select(count)end if(sub=='up' or sub=='u')then turtle.dropUp()elseif(sub=='down' or sub=='d')then turtle.dropDown()else turtle.drop()end else turtle.drop()end end table.insert(chat.interactiveCommands,'farm')function chat.cmd.farm(f_type,x,y,keepRepeating)if(f_type and tonumber(f_type))then f_type,x,y,keepRepeating=nil,f_type,x,y end local search=f_type and(f_type..'_sapling')or '_sapling' local inventory=backpack.getInventory()local saplingSlot=nil local ok,inspect=turtle.inspectDown()local chestSlot=nil if(ok and inspect.name:match('chest'))then chestSlot=true else chestSlot=inventory:getSlotWith('chest')if(chestSlot)then turtle.digDown()turtle.select(chestSlot)turtle.placeDown()end end function placeItemsInChest()inventory:update()inventory:compact()if(not chestSlot)then local plankSlot=inventory:getSlotWith('planks')if(not plankSlot)then craft.craft('plank',2,inventory)elseif(inventory[plankSlot].count<8)then craft.craft('plank',2-math.floor(inventory[plankSlot].count / 2),inventory)end craft.craft('chest',1,inventory)chestSlot=inventory:getSlotWith('chest')if(not chestSlot)then return false end turtle.digDown()turtle.select(chestSlot)turtle.placeDown()end for slot,item in pairs(inventory)do if(item.name:match('log'))then turtle.select(slot)turtle.dropDown()end end return true end function selectSapling()inventory:update()saplingSlot=inventory:getSlotWith(search)if(saplingSlot)then return turtle.select(saplingSlot)else return false end end function refuel(x,y)local expectedNeeded=(x*3+2)*(y*3+3)+(x*y*20)local function _refuel()inventory:update()local coalSlot=inventory:getSlotWith('coal')if(coalSlot)then drone.select(coalSlot)return drone.refuel(math.floor(expectedNeeded/80)+1)end return false end if(drone.getFuelLevel()-expectedNeeded<50)then if(_refuel())then return true end drone.go('r2f')chat.cmd.smelt('log')local refueled=_refuel()drone.go('r2f')return refueled end return false end local x,y=tonumber(x)or 3,tonumber(y)or 2 local repeatLoop=true waiter.serve(function()while(repeatLoop)do refuel(x,y)if(not placeItemsInChest())then return end drone.go('ulf2rf')drone.suckDown()for yI=1,y*3+2 do for xI=1,x do if(not drone.forward())then return end drone.suckDown()if(yI>0 and yI % 3==0)then ok,inspect=turtle.inspect()if(ok and inspect.name:match('log'))then drone.down()chat.cmd.mine('tree')drone.up()elseif(ok)then print('encountered non tree block')return end if(not drone.forward())then return end drone.suckDown()if(selectSapling())then turtle.placeDown()end else if(not drone.forward())then return end drone.suckDown()end if(not drone.forward())then return end drone.suckDown()end if(not drone.forward())then return end drone.suckDown()if(yI % 2==0)then drone.go('lfl')drone.suckDown()else drone.go('rfr')drone.suckDown()end end if(y % 2==0)then drone.go('l')drone.forward(y*3-1)drone.go('lfdl2')else drone.go('rfl')drone.forward(x*3+2)drone.go('rf'..(y*3-1)..'rd')end local refueled=refuel(x,y)placeItemsInChest()if(not keepRepeating)then repeatLoop=false elseif(not refueled)then wait(60)else wait(10)end end end)repeatLoop=false end function chat.cmd.mine(sub,...)if(sub==nil)then drone.dig()elseif(sub=='down')then drone.digDown()local ok,err=drone.down()if(not ok and err=='Out of fuel')then drone.refuel()drone.down()end local params={...}if(tonumber(params[1]))then for i=2,tonumber(params[1])do drone.digDown()turtle.down()end end elseif(sub=='up')then drone.digUp()local ok,err=drone.up()if(not ok and err=='Out of fuel')then drone.refuel()drone.up()end local params={...}if(tonumber(params[1]))then for i=2,tonumber(params[1])do drone.digUp()turtle.up()end end elseif(sub=='resource')then local params={...}local length=tonumber(params[1])or 40 local times=tonumber(params[2])or 2 local refuel=function(length)while(turtle.getFuelLevel()<length)do local slot=backpack.getSlotWith(backpack.vars.fuel)if(slot)then turtle.select(slot)turtle.refuel(math.ceil(length/80)+1)else break end end return turtle.getFuelLevel()>=length end if(not refuel(length))then return end local inventory=backpack.getInventory()backpack.cleanup(inventory)local ok,down=turtle.inspectDown()local chestSlot=false if(ok and down.name:match('chest'))then chestSlot=true else chestSlot=backpack.getSlotWith('chest',inventory)if(not chestSlot and craft.canCraft('chest',inventory))then craft.craft('chest',inventory)chestSlot=backpack.getSlotWith('chest',inventory)end if(chestSlot)then turtle.digDown()turtle.select(chestSlot)turtle.placeDown()end end if(chestSlot)then inventory:foreach(function(slot,item)if(not linq:any(backpack.vars.fuel,function(k,name)return item.name:match(name)end))then turtle.select(slot)turtle.dropDown()end end)end local toStart=function(tunnelNumber,tunnelDepth)if(times % 2==0)then if(tunnelDepth==length)then refuel(2)drone.goDig('dd')else refuel(length-tunnelDepth+3)drone.goDig('ddlf2r')drone.forward(length-tunnelDepth)end else refuel(tunnelDepth)drone.turnAround()drone.forward(tunnelDepth)end turtle.turnLeft()refuel((times-1)*2)for i=1,(times-1)*2 do drone.dig()turtle.forward()end turtle.turnLeft()end local storeShit=function(tunnelNumber,tunnelDepth,inventory)inventory=inventory or backpack.getInventory()backpack.cleanup(inventory)if(not backpack.isFull(inventory))then return true end if(not refuel(tunnelDepth))then return false end toStart(tunnelNumber,tunnelDepth)if(chestSlot)then backpack.getInventory(inventory)inventory:foreach(function(slot,item)if(not linq:any(backpack.vars.fuel,function(k,name)return item.name:match(name)end))then turtle.select(slot)turtle.dropDown()end end)local moveDepth=(tunnelNumber-1)*2 if(not refuel(tunnelDepth+moveDepth))then return false end drone.turnAround()drone.forward(moveDepth)drone.turnRight()drone.forward(tunnelDepth)return true end return false end local q=0 for x=1,times do q=q+1 if(not refuel(length))then return toStart(x-1,0)end for i=1,length do if(q % 32==0)then local inventory=backpack.getInventory()backpack.cleanup(inventory)if(not storeShit(x,i,inventory))then return end end drone.dig()turtle.forward()miner.excavate()if(x % 2==0)then drone.digDown()else drone.digUp()end if(not refuel(length-i))then return toStart(x,i)end end if(not storeShit(x,length))then return end if(x<times)then if(not refuel(4))then return end if(x % 2==0)then drone.goDig('rffddr')else drone.goDig('lffuul')end end end toStart(times,length)elseif(sub=="stairs")then local params={...}if(#params==0)then return end local depth=tonumber(params[1])local function digForward(reset)drone.goDig('flf0')if(reset==nil or reset==true)then turtle.turnRight()end end local function digDown(flipped)drone.goDig(flipped and 'drf0l' or 'dlf0r')end local inventory=backpack.getInventory()local stairSlot=backpack.getSlotWith('stairs',inventory)if(not stairSlot)then craft.craft('stairs')inventory=backpack.getInventory(inventory)end while(depth>0)do depth=depth-1 stairSlot=backpack.getSlotWith('stairs',inventory)if(depth % 10==0)then backpack.cleanup()end digDown()digForward()digForward()digForward()if(stairSlot)then digForward(false)drone.go('lf3')drone.select(stairSlot)drone.place()drone.go('rfl')drone.place()drone.go('rbr')inventory[stairSlot].count=inventory[stairSlot].count-2 else digForward()drone.back(3)end end elseif(sub=='grid')then local params={...}if(params[1]=='?')then end local w,d,h=tonumber(params[1]),tonumber(params[2] or params[1]),tonumber(params[3] or 2)local toRight,inBox=true,false if(d<w)then drone.dig()drone.forward()if(h>1)then drone.digUp()end drone.right()toRight=false inBox=true d,w=w,d end for z=1,h,2 do for x=1,w do for y=inBox and 2 or 1,d do inBox=true chat.cmd.mine('tree')drone.dig()drone.forward()if(z<h)then drone.digUp()end end if(x<w)then if(toRight)then drone.right()else drone.left()end chat.cmd.mine('tree')drone.dig()drone.forward()if(z<h)then drone.digUp()end if(toRight)then drone.right()else drone.left()end toRight=not toRight end end if(z<(h-1))then drone.right(2)drone.digUp()drone.up()drone.digUp()drone.up()end end if(h>2)then drone.digDown()end drone.down(h-1)elseif(sub=='tree')then local ok,data=drone.inspect()if(ok and data.name:match('log'))then local emptySlot=0 for slot=1,16 do local slotItem=drone.getItemDetail(slot)if(slotItem==nil)then emptySlot=slot elseif(slotItem.name:match('log'))then drone.select(slot)if(drone.compare())then emptySlot=slot break end end end if(emptySlot>0)then drone.select(emptySlot)end drone.dig()local ok,err=drone.forward()if(not ok and err=='Out of fuel')then drone.refuel(1)drone.forward()end local up=0 while(drone.compareUp())do drone.digUp()if(not drone.up())then drone.refuel(1)if(not drone.up())then break end end up=up+1 end drone.down(up)drone.back()end end end function chat.cmd.smelt(sub)if(not sub)then print('ore or slot required')return end local smeltables=backpack.vars.smeltable local fallbackName=_HOST:match('Minecraft 1.12')and sub..smeltables[1] or smeltables[1]..sub local inventory=backpack.getInventory()local oreSlot=tonumber(sub)or(linq:any(smeltables,function(k,name)return sub:match(name)end)and backpack.getSlotWith(sub,inventory)or backpack.getSlotWith(fallbackName,inventory))if(not oreSlot or not inventory[oreSlot] or not linq:any(smeltables,function(k,name)return inventory[oreSlot].name:match(name)end))then print('No smeltable found')return end local ok,inFront=turtle.inspect()local furnaceSlot=nil if(not ok or not inFront.name:match('furnace'))then furnaceSlot=backpack.getSlotWith('furnace',inventory)if(not furnaceSlot)then print('No furnace found')return end end local fuelSlot=backpack.getSlotWith(backpack.vars.fuel)if(not fuelSlot)then print('No fuel found')return end if(furnaceSlot)then drone.dig()turtle.select(furnaceSlot)turtle.place()end turtle.select(fuelSlot)turtle.drop(fuelSlot==oreSlot and 1 or nil)drone.goDig('uf')turtle.select(oreSlot)local oreCount=inventory[oreSlot].count turtle.dropDown()local function isLit()if(_HOST:match('Minecraft 1.12'))then local ok,block=turtle.inspectDown()return ok and block.name:match('lit')else local ok,block=turtle.inspectDown()return ok and block.state.lit end end while(isLit()and oreCount>0)do wait(10)oreCount=oreCount-1 end if(furnaceSlot)then backpack.compact()drone.goDig('db')else drone.goDig('bddf')backpack.compact()turtle.suckUp()turtle.back()turtle.up()end backpack.compact()end chat.cmd.excavate=miner.excavate chat.cmd.craft=craft.craft chat.cmd.compact=backpack.compact chat.cmd.clean=backpack.cleanup function chat.cmd.fuel()print(drone.getFuelLevel())end function chat.cmd.refuel(count)drone.refuel(count and tonumber(count)or nil)end chat.cmd.clear=console.clear chat.cmd.up=drone.up chat.cmd.down=drone.down chat.cmd.back=drone.back chat.cmd.forward=drone.forward chat.cmd.left=drone.left chat.cmd.right=drone.right chat.cmd.go=drone.go function chat.cmd.select(slot)if(slot==nil or tonumber(slot))then drone.select(tonumber(slot)or 1)else drone.select(backpack.getSlotWith(slot)or 1)end end run(function()backpack.equip('modem','right')while(chat.run())do stateH.save()backpack.equip('modem','right')end end)
