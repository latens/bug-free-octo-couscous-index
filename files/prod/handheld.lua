local _builddate = '2024-11-25 21:00:40';print(_builddate)
         function string.starts(String,Start)return string.sub(String,1,string.len(Start))==Start end function string.before(String,Start)return string.sub(String,1,string.len(Start))end function string.after(String,Start)return string.sub(String,string.len(Start)+1)end function string.split(inputstr,sep)if sep==nil then sep="." end local t={}for str in string.gmatch(inputstr,"([^"..sep.."]+)")do table.insert(t,str)end return t end function string.trim(s)return(string.gsub(s,"^%s*(.-)%s*$","%1"))end function string.join(params,glue)if(#params==1)then return tostring(params[1])end glue=glue or '.' local t={}for k,v in ipairs(params)do t[#t+1]=tostring(v)end return table.concat(t,glue)end function firstToUpper(str)return(str:gsub("^%l",string.upper))end if(class==nil)then class={}end class=function(classDef,parentClass)if classDef.super or classDef.new or classDef.is then error("super and new can not exist within class defenitions",2)end if parentClass then setmetatable(classDef,{__index=parentClass})classDef.super=parentClass end function classDef:new(...)local new={}setmetatable(new,{__index=self})if new.constructor then new:constructor(...)end return new end function classDef:is(c)local selfTable=getmetatable(self)local cTable=getmetatable(c)return(selfTable~=nil and c==selfTable.__index)or(cTable~=nil and self==cTable.__index)end return classDef end if(convert==nil)then convert={}end function convert.toJson(message)return textutils.serialise(message)end function convert.fromJson(message)if(type(message)=="table")then return message end if(type(message)=="string")then return textutils.unserialise(message)end return nil end function convert.isJson(message)local json=convert.fromJson(message)return json~=nil,json end function convert.toLocation(loc,y,z)local location={}if(loc==nil)then return location end if(type(loc)=="table")then location.x=tonumber(loc.x)or tonumber(loc[1])or 0 location.y=tonumber(loc.y)or tonumber(loc[2])or 0 location.z=tonumber(loc.z)or tonumber(loc[3])or 0 else location.x=tonumber(loc)or 0 location.y=tonumber(y)or 0 location.z=tonumber(z)or 0 end location[1]=location.x location[2]=location.y location[3]=location.z return location end if(files==nil)then files={}end function files.write(name,content)local file=fs.open(name,"wb")file.write(content)file.close()end function files.read(name)if(not fs.exists(name))then return nil end local file=fs.open(name,"r")local contents=file.readAll()file.close()return contents end function files.writeJson(name,content)return files.write(name,textutils.serialiseJSON(content))end function files.readJson(name)local content=files.read(name)return content and textutils.unserialiseJSON(content)or nil end if(method==nil)then method={}end local native_select,native_type=select,type local function get_type_names(...)local types=table.pack(...)for i=types.n,1,-1 do if types[i]=="nil" then table.remove(types,i)end end if #types<=1 then return tostring(...)else return table.concat(types,",",1,#types-1).." or "..types[#types] end end function method.expect(index,value,...)local t=native_type(value)for i=1,native_select("#",...)do if t==native_select(i,...)then return value end end local name local ok,info=pcall(debug.getinfo,3,"nS")if ok and info.name and info.name~="" and info.what~="C" then name=info.name end local type_names=get_type_names(...)if name then error(("bad argument #%d to '%s'(expected %s,got %s)"):format(index,name,type_names,t),3)else error(("bad argument #%d(expected %s,got %s)"):format(index,type_names,t),3)end end if(var==nil)then var={}end var.sides={"right","left","up","bottom","front","back"}var.directions={"north","east","south","west"}var.isOldMinecraft=_HOST:match('Minecraft 1.12')if(try==nil)then try={}end try=setmetatable(try,{__call=function(self,func,...)local result={pcall(func,...)}if(table.remove(result,1))then return unpack(result)else print('ERR','try()',result[1])end end})function try.catch(startFunc,catchFunc)local result={pcall(startFunc)}if(table.remove(result,1))then return unpack(result)else catchFunc(result[1])end end Responder={}Responder.__index=Responder if(Responder==nil)then Responder={}end function Responder:new(functionToWrap)assert(self,"missing receiver")local r=setmetatable({},self)r.func=functionToWrap r.co=coroutine.create(r.func)if(r.co==nil)then error('Could not create new responder')end return r end function Responder:__call(...)if self:canResume()then local response={coroutine.resume(self.co,...)}if(not response[1])then print('ERR: in Responder:__call')print(response[2])end table.remove(response,1)if(type(response[1])=='function')then self.check=response[1] table.remove(response,1)else self.check=nil end return true,response else return false end end function Responder:stop()self.co=nil end function Responder:finished()return self.co==nil or coroutine.status(self.co)=="dead" end function Responder:canResume()if not self:finished()then if self.check then return self:check()else return true end end return false end function extract(tbl,...)local toIterate={...}local result={}for k,name in ipairs(toIterate)do result[k]=tbl[name] or nil end return unpack(result,1,#toIterate)end if(linq==nil)then linq={}end if(_linq==nil)then _linq={}end function _linq._iterator(self,iteratorfunc)for i,keyvalue in ipairs(self.cache)do coroutine.yield(keyvalue[1],keyvalue[2],i)end local i=#self.cache+1 if(not self.done and self.parent~=nil)then local pIterator=self.parent.getIterator()local pDone,pKey,pValue=pIterator()while(not pDone and pKey~=nil and not self.done)do if(self.filter==nil or self.filter(pKey,pValue,i,self))then if(iteratorfunc)then pKey,pValue=iteratorfunc(pKey,pValue,i,self)end self.cache[i]={pKey,pValue}coroutine.yield(pKey,pValue,i)i=i+1 end pDone,pKey,pValue=pIterator()end end if(not self.done and self.data)then for k,v in pairs(self.data)do if(not self.done and self.filter==nil or self.filter(k,v,i,self))then if(iteratorfunc)then k,v=iteratorfunc(k,v,i,self)end self.cache[i]={k,v}coroutine.yield(k,v,i)i=i+1 end end end end function _linq._wrap(func)local co=Responder:new(func)return function(...)_,response=co()if(not co:canResume())then return true end if(type(response)~='table')then error('expected table')end response=response or{}return false,response[1],response[2] end end linq=class({constructor=function(self,params)self.new=nil self.isLinq=true local data,filter,iterator,parent=params.data,params.filter,params.iterator,params.parent self.getIterator=function()return _linq._wrap(function()if(iterator)then iterator(self)else _linq._iterator(self)end self.done=true end)end if(type(filter)=='string' or type(filter)=='number')then filter=function(k,v)return v==filter end end self.filter=filter self.cache={}self.data=data self.parent=parent end,cache=nil,data=nil,done=false,filter=nil,parent=nil,isLinq=false,newSubQuery=function(self,params)params.parent=self return linq:new(params)end})function linq:where(data,func)if(func~=nil)then return linq:new({data=data,filter=func})else func=data return self:newSubQuery({filter=func})end end function linq:take(data,count)if(count~=nil)then return linq:new({data=data,filter=function(k,v,i,self)self.done=i==count return k<=count end})else count=data return self:newSubQuery({filter=function(k,v,i,self)self.done=i==count return i<=count end})end end function linq:skip(data,count)if(count~=nil)then count=count+1 return linq:new({data=data,filter=function(k,v,i)count=count-1 return k>count end})else count=data+1 return self:newSubQuery({filter=function(k,v,i)count=count-1 return k>count end})end end function linq:join(dataA,dataB)if(dataB==nil)then dataA,dataB=self,dataA if(not dataA.isLinq)then error('linq:join expected two arguments')end end if(dataA.isLinq)then if(dataB.isLinq)then return linq:new({iterator=function()_linq._iterator(dataA)_linq._iterator(dataB)end})else return self:newSubQuery({data=dataB})end else return linq:new({parent=linq:new({data=dataA}),data=dataB})end end function linq:reverse()local oldSelf=self return linq:new({iterator=function(self)self.data={}local tempData={}oldSelf:each(function(k,v)table.insert(tempData,{k,v})end)local y=1 for i=#tempData,1,-1 do self.data[y]=tempData[i] y=y+1 end tempData=nil _linq._iterator(self,function(key,value)return value[1],value[2] end)end})end function linq:getSorted(data,func)if(data==nil)then return linq:getSorted(self:get())elseif(func==nil)then table.sort(data)return data elseif(type(func)=='function')then table.sort(data,func)return data else print('linq:sort','unknown arguments',data,func)end end function linq:get()local data={}local iterator=self.getIterator()local pDone,pKey,pValue=iterator()while(not pDone)do table.insert(data,pValue)pDone,pKey,pValue=iterator()end return data end function linq:first(data)if(data==nil)then local iterator=self.getIterator()local pDone,pKey,pValue=iterator()return not pDone and pValue else for k,v in pairs(data)do return v end end end function linq:last()local iterator=self.getIterator()local pDone,pKey,pValue=iterator()local last=pValue while(not pDone)do last=pValue pDone,pKey,pValue=iterator()end return last end function linq:_cache()local iterator=self.getIterator()while(not iterator())do end end function linq:any(data,funcOrData)if(data==nil)then local iterator=self.getIterator()local pDone=iterator()return not pDone elseif(type(funcOrData)=='function')then for k,v in pairs(data)do if(funcOrData(k,v))then return true end end return false elseif(funcOrData~=nil)then for k,v in pairs(data)do if(v==funcOrData)then return true end end return false elseif(type(data)=='table')then for k,v in pairs(data)do return true end return false else return self:where(data):any()end end linq.contains=linq.any function linq:each(data,func)if(func==nil)then func=data return self:newSubQuery({iterator=function(self)_linq._iterator(self,func)end}):get()else return linq:new({data=data,iterator=function(self)_linq._iterator(self,func)end}):get()end end function linq:select(data,func)if(func==nil)then func=data return self:newSubQuery({iterator=function(self)_linq._iterator(self,function(k,v)return k,func(k,v)end)end})else return linq:new({data=data,iterator=function(self)_linq._iterator(self,function(k,v)return k,func(k,v)end)end})end end linq.map=linq.select function linq:remove()local function getData(linqItem)if(linqItem.parent~=nil)then return getData(linqItem.parent)end return linqItem.data end local data=getData(self)self:reverse():each(function(k,v)table.remove(data,k)end)end function linq:indexOf(data,obj)if(obj==nil)then obj=data return self:where(function(k,v)return v==obj end):select(function(k)return k end):first()else return linq:new({data=data}):indexOf(obj)end end if(log==nil)then log={}end loglevel=settings.get('loglevel')or 3 function log.setLoglevel(level)if(type(level)=="string")then if(level=="error")then loglevel=4 end if(level=="warning")then loglevel=3 end if(level=="info" or level=="information")then loglevel=2 end if(level=="verbose")then loglevel=1 end settings.set("loglevel",loglevel)elseif(type(level)=="number")then loglevel=level settings.set("loglevel",level)end end function log._log(filter,...)if(loglevel<=filter)then print(string.join({...},''))return true else return false end end function log.logError(...)return log._log(4,...)end function log.logWarning(...)return log._log(3,...)end function log.logInformation(...)return log._log(2,...)end function log.logVerbose(...)return log._log(1,...)end function log.bool(boolean)return boolean and 'true' or 'false' end log.logInfo=log.logInformation if(tables==nil)then tables={}end function tables.removeMany(t,fnRemove)if(fnRemove==nil)then return t end local typ=type(fnRemove)local j,n=1,#t if(typ=='function')then for i=1,n do if(fnRemove(t,i,j))then t[i]=nil; else if(i~=j)then t[j]=t[i]; t[i]=nil; end j=j+1; end end else for i=1,n do if(t[i]==fnRemove)then t[i]=nil; else if(i~=j)then t[j]=t[i]; t[i]=nil; end j=j+1; end end end if(#t>j)then n=#t for i=j,n do if(t[i]~=nil)then if(i~=j)then t[j]=t[i]; t[i]=nil; end j=j+1; end end end return t; end function tables.iShallowCopy(t)if(#t==0)then return t end local t2={}for k,v in ipairs(t)do t2[k]=v end return t2 end function tables.deepCopy(t)local t2={}for k,v in pairs(t)do if(type(v)=='table')then t2[k]=tables.deepCopy(v)else t2[k]=v end end return t2 end function tables.immutableInsert(t,item,index)index=index or(#t+1)local newT=tables.iShallowCopy(t)table.insert(newT,index,item)return newT end function tables.sortBy(t,property,...)if(...==nil)then table.sort(t,function(a,b)return a[property]<b[property] end)else local properties={property,...}table.sort(t,function(a,b)for i=1,#properties do if(a[properties[i]]<b[properties[i]])then return true end if(a[properties[i]]>b[properties[i]])then return false end end end)end return t end function tables.sortByDescending(t,property,...)if(...==nil)then table.sort(t,function(a,b)return a[property]>b[property] end)else local properties={property,...}table.sort(t,function(a,b)for i=1,#properties do if(a[properties[i]]>b[properties[i]])then return true end if(a[properties[i]]<b[properties[i]])then return false end end end)end return t end tables.sortByAscending=tables.sortBy if(rx==nil)then rx={}end function rx.errorWrapper(f,name,errType)return function(...)local ok,err=pcall(f,...)if(not ok)then print('ERR:',errType or '',name or '')print(err)end end end EventTable={}EventTable.__index=EventTable function EventTable:on(optsOrName,f,filter)local opts if type(optsOrName)=="table" then opts=optsOrName else opts={event=optsOrName,f=f,filter=filter}end local name=opts.event assert(type(name)=="string" and name~="",":on requires an event name")assert(type(opts.f)=="function",":on requires an event handler")if(opts.handler)then opts.fWrapped=opts.handler else opts.fWrapped=rx.errorWrapper(opts.f,name,'EVENT')end self[name]=self[name] or{}table.insert(self[name],opts)return opts.f end function EventTable:off(name,responder)if(name==nil)then return end if responder and self[name] then tables.removeMany(self[name],function(t,i)return t[i].f==responder end)elseif(type(name)=='string')then self[name]=nil elseif(type(name)=='function')then if(self['timer'])then tables.removeMany(self['timer'],function(t,i)return t[i].f==name end)end tables.removeMany(self._unfinishedResponders,function(t,i)return t[i].func==name end)end end function EventTable:dispatch(name,...)if(self[name]==nil or #self[name]==0)then return false end local sent=false local args={...}tables.removeMany(self[name],function(t,i)local responder=t[i] if type(responder.filter)=="function" and not responder.filter(table.unpack(args))then return false else local f,ok,fResult if(responder.handler)then f=responder.handler ok,fResult=f(name,table.unpack(args))else f=Responder:new(responder.fWrapped)ok,fResult=f(table.unpack(args))end sent=true if not f:finished()then if(type(fResult)=='table' and type(fResult[1])=='string')then local event,filter=fResult[1],fResult[2] if(responder.handler and name==event)then responder.filter=type(filter)=='function' and filter return false else self:on({event=event,handler=f,f=responder.f,filter=type(filter)=='function' and filter,once=false})end else self:addResponder(f)end end return responder.handler~=nil or responder.once end end)return sent end function EventTable:addResponder(responder)table.insert(self._unfinishedResponders,responder)end function EventTable:resume()local newUnfinishedResponders={}for _,responder in ipairs(self._unfinishedResponders)do local ok,fResult=responder()if not responder:finished()then if(ok and type(fResult[1])=='string')then self:on({event=fResult[1],handler=responder,f=responder.func,filter=type(fResult[2])=='function' and fResult[2],once=false})else table.insert(newUnfinishedResponders,responder)end end end self._unfinishedResponders=newUnfinishedResponders end function EventTable:new()assert(self,"missing receiver")local et=setmetatable({},self)et._unfinishedResponders={}return et end local osEvents=EventTable:new()function on(...)return osEvents:on(...)end function off(...)return osEvents:off(...)end function add(func)local responder=Responder:new(rx.errorWrapper(func,'add'))osEvents:addResponder(responder)return responder.func end function queue(...)os.queueEvent(...)end function waitUntil(checkFunc)if(not checkFunc())then coroutine.yield(checkFunc)end end function once(event,func,filter)if(type(event)=='table')then local opts=event event=opts.event func=opts.f or opts.func filter=opts.filter end return on{event=event,filter=filter,once=true,f=func}end function wait(seconds,cancelFunction)local ourID=os.startTimer(seconds)if(cancelFunction~=nil)then local fired=false local onListener=on{event="timer",filter=function(timerID)return timerID==ourID or fired end,once=true,f=function()fired=true end}waitUntil(function()return fired or cancelFunction()end)off('timer',onListener)os.cancelTimer(ourID)else coroutine.yield('timer',function(id)return id==ourID end)end end function waitForEvent(event,filter)return coroutine.yield(event,filter)end rx.debouncers={}function prebounce(name,func)if(rx.debouncers[name] or type(func)~='function')then return end rx.debouncers[name]={on=add(function()rx.debouncers[name]=nil end)}return func()end function debounce(name,func,timeout)rx.debouncers[name]=rx.debouncers[name] or{}local db=rx.debouncers[name] if(timeout)then if(db.id)then os.cancelTimer(db.id)off('timer',db.on)end db.id=os.startTimer(timeout)db.on=on{event="timer",filter=function(timerID)return timerID==db.id end,once=true,f=function()rx.debouncers[name]=nil func()end}else if(db.on)then off(db.on)end db.on=add(function()rx.debouncers[name]=nil func()end)end end function run(mainFunction)mainFunction=mainFunction or function()while(true)do wait(10)end end if mainFunction then ok,err=pcall(add,function()mainFunction()quit()end)if(not ok)then print('run err')print(err)end ok,err=pcall(osEvents.resume,osEvents)if(not ok)then print('run err2')print(err)end end while true do local event={os.pullEventRaw()}local eventName=event[1] local handled=osEvents:dispatch(unpack(event))if not handled then if eventName=="terminate" then print("Shutting down")break end end osEvents:resume()end end function quit()queue('terminate')end if(parallel==nil)then parallel={}end parallel.waitForAll=function(tbl,...)local funcs=type(tbl)=='table' and tbl or{tbl,...}local todo=#funcs for k,func in ipairs(funcs)do add(function()func()todo=todo-1 end)end waitUntil(function()return todo==0 end)end parallel.waitForAny=function(tbl,...)local funcs=type(tbl)=='table' and tbl or{tbl,...}local todo=1 local handlers={}for k,func in ipairs(funcs)do handlers[k]=add(function()func()todo=todo-1 end)end waitUntil(function()return todo==0 end)for k,v in ipairs(handlers)do off(v)end end parallel._meta={__index={new=function(self)for i=#self,1,-1 do self[i]=nil end return self end,add=table.insert,run=parallel.waitForAll,waitForAll=parallel.waitForAll,waitForAny=parallel.waitForAny}}parallel._meta.__index.clear=parallel._meta.__index.new parallel.new=function()return setmetatable({},parallel._meta)end if(network==nil)then network={}end network.addr={}network.senderID=os and os.getComputerID()or 0 network.protocol="BIFORMATION.PLAIN.V2" network.queueUpdates=true network.hasModem=peripheral.find('modem',function(name,wrapped)return wrapped.isWireless()end)~=nil add(function()on({event='peripheral',filter=function(side)return peripheral.hasType(side,'modem')and not peripheral.hasType(side,'peripheral_hub')end,once=false,f=function(side)network.hasModem=true network.open(side)end})on({event='peripheral_detach',once=false,f=function()network.hasModem=false for k,modem in ipairs({peripheral.find('modem')})do network.hasModem=modem.isWireless()if(network.hasModem)then network.open()break end end end})end)rednet.CHANNEL_BROADCAST=51932 local cAddress=class({constructor=function(self,name,id)self.name=name self.id=id self.dropped=0 end})function network.getIds(name)return network.hasAddress(name)and linq:select(network.addr[name].points,function(key,value)return value.id end):get()or{}end function network.getAddresses(name)if(name)then return network.addr[name]~=nil and network.addr[name].points else return network.addr end end function network.getTypes()local types={}for typ,adr in pairs(network.addr)do table.insert(types,typ)end return types end function network.hasAddress(name)return network.addr[name]~=nil and linq:any(network.addr[name].points)end function network.printAddresses(name)for typ,adr in pairs(network.addr)do if(not name or typ==name)then log.logInformation(typ,':',string.join(linq:select(adr.points,function(key,value)return value.id end):getSorted(),','))end end end function network.getCurrentAddress(name)if(not network.hasAddress(name))then return nil end local address=network.addr[name] address.pointer=((address.pointer-1)% #address.points)+1 return address.points[address.pointer] end function network.getAddress(name)if(not network.hasAddress(name))then return nil end network.addr[name].pointer=(network.addr[name].pointer % #network.addr[name].points)+1 return network.getCurrentAddress(name)end function network.addAddress(name,id)if(not network.hasAddress(name))then network.addr[name]={points={},pointer=0}end if(not linq:where(network.addr[name].points,function(k,v)return v.id==id end):any())then table.insert(network.addr[name].points,cAddress:new(name,id))if(network.queueUpdates)then queue('network_address_added',{name=name,id=id})end end end function network.removeAddress(name,id)if(not network.hasAddress(name))then return nil end linq:where(network.addr[name].points,function(k,v)return v.id==id end):take(1):remove()if(network.queueUpdates)then queue('network_address_removed',{name=name,id=id,anyLeft=network.hasAddress(name)})end end function network.clearAddress(name)if(not network.hasAddress(name))then return nil end if(network.queueUpdates)then local addressIds=linq:select(network.addr[name].points,function(key,value,i)return value.id end):get()for k,id in ipairs(addressIds)do queue('network_address_removed',{name=name,id=id,anyLeft=false})end end network.addr[name]=nil end function network.clearAddresses()if(network.queueUpdates)then for name,addr in pairs(network.addr)do local addressIds=linq:select(addr.points,function(key,value,i)return value.id end):get()for k,id in ipairs(addressIds)do queue('network_address_removed',{name=name,id=id,anyLeft=false})end end end network.addr={}end function network.targetToAddress(target)local address if(type(target)=='table' and cAddress:is(target))then address=target elseif(type(target)=='string')then address=network.getAddress(target)end return address~=nil,address end function network.markAddressDropped(address)if(not cAddress:is(address))then return end address.dropped=address.dropped+1 if(address.dropped>2)then network.removeAddress(address.name,address.id)end end function network.markAddressReceived(address)if(not cAddress:is(address))then return end address.dropped=0 end function network.onNetworkAddressAdded(name,callback)on({event='network_address_added',filter=function(obj)return obj.name==name end,once=false,f=callback})if(network.hasAddress(name))then add(function()for k,v in ipairs(network.getAddresses(name))do callback(v)end end)end end function network.onNetworkAddressRemoved(name,callback)on({event='network_address_removed',filter=function(obj)return obj.name==name end,once=false,f=callback})if(not network.hasAddress(name))then add(function()callback({name=name,id=-1,anyLeft=false})end)end end function network.update(newAddresses)local seenTypes={}local anyChange=false for typ,addressList in pairs(newAddresses)do table.insert(seenTypes,typ)local ids=linq:select(addressList.points,function(k,v)return v.id end):get()local existingIds=network.getIds(typ)for k,existingId in ipairs(existingIds)do if(not linq:contains(ids,existingId))then anyChange=true network.removeAddress(typ,existingId)end end for k,newId in ipairs(ids)do if(not linq:contains(existingIds,newId))then anyChange=true network.addAddress(typ,newId)end end end for k,typ in ipairs(network.getTypes())do if(not linq:contains(seenTypes,typ))then anyChange=true network.clearAddress(typ)end end return anyChange end function network.open(side)if(not network.hasModem)then return false end if(rednet.isOpen())then return true end if(side~=nil)then pcall(rednet.open,side)else local i=1 local tbl={peripheral.find('modem',function(name,wrapped)return wrapped.isWireless()end)}while(not rednet.isOpen()and i<=#tbl)do pcall(rednet.open,peripheral.getName(tbl[i]))i=i+1 end end local isOpen=rednet.isOpen()if(isOpen)then log.logVerbose("Connected to network")else log.logWarning("Failed to connect to network")end return isOpen end function network.receive(timeout,filter,identifier)local receiveFilter=function(sender,message,protocol)return protocol==network.protocol and(filter and filter(sender,message,protocol))end local senderId,message,protocol if(timeout==nil)then senderId,message,protocol=coroutine.yield('rednet_message',receiveFilter)else local ourID=os.startTimer(timeout)local response=nil local handler=on({event='rednet_message',filter=receiveFilter,once=true,f=function(fSenderId,FMessage,fProtocol)response={fSenderId,FMessage,fProtocol or '_'}queue('timer',ourID)end})coroutine.yield('timer',function(id)return id==ourID end)if(response)then os.cancelTimer(ourID)senderId,message,protocol=unpack(response)else off('rednet_message',handler)end end if(senderId~=nil)then log.logVerbose("Received message from #",senderId,' for ',identifier or message.url)return message,senderId else log.logVerbose("Received no ",identifier or(message and message.url),"message within ",(timeout or-1)," seconds")return nil,nil end end function network.receiveMany(callback,timeout,filter,identifier)identifier=identifier or '' local eventHandler=on({event='rednet_message',filter=function(sender,message,protocol)return protocol==network.protocol and(filter==nil or filter(sender,message,protocol))end,once=false,f=function(sender,message,protocol)callback(message,sender)end})if(timeout~=nil)then wait(timeout)log.logVerbose("Network ",identifier,"receiver timed out")off('rednet_message',eventHandler)end end function network.broadcast(message)method.expect(1,message,'table')if(not network.open())then return nil end message.type=message.type or 'REQUEST' message.headers=message.headers or{}message.headers.sender=network.senderID message.headers.corID=message.headers.corID or math.random(0,9999)log.logVerbose("Broadcasting ",(message.url or "")," to network")return rednet.broadcast(message,network.protocol)end function network.send(message,receiver)method.expect(1,message,'table')method.expect(2,receiver,'number')if(not network.open())then return nil end message.headers=message.headers or{}message.headers.sender=network.senderID message.headers.corID=message.headers.corID or math.random(0,9999)log.logVerbose("Send to #",receiver,' at ',message.url)return rednet.send(receiver,message,network.protocol)end function network.respond(request,response)network.send({type='RESPONSE',url=request.url,method=request.method,headers={request=request,corID=request.headers.corID},body=response},request.headers.sender)end function network.get(...)return network._send('GET',...)end function network.post(...)return network._send('POST',...)end function network.put(...)return network._send('PUT',...)end function network._send(method,target,url,headers,body,timeout)local ok,address=network.targetToAddress(target)if(ok)then target=address.id end if(type(target)~='number')then log.logError("network.targetToAddress failed",type(target))return false end local message={type='REQUEST',method=method,url=url,headers=headers or{},body=body or{}}network.send(message,target)local responseMessage,responseSender=network.receive(timeout or 10,function(sender,received,protocol)return received.type=='RESPONSE' and received.headers.corID==message.headers.corID end)return responseMessage end if(console==nil)then console={}end console.oPrint=print console.output={}console.width,console.height=term.getSize()console.printLine=5 console.show=true console.printType=function(obj)local typ=type(obj)if(typ=='function')then return '#func' elseif(typ=='boolean')then return obj and 'true' or 'false' elseif(obj==nil)then return 'nil' else return obj end end print=function(...)local line if(...)then local tbl={}local args={...}for i=1,select("#",...)do tbl[i]=console.printType(args[i])end line=table.concat(tbl,' ')else line='' end table.insert(console.output,line)if(not console.show)then return end local y=math.max(2,math.min(console.printLine,console.height))local max=math.ceil(#line / console.width)for i=1,max do term.setCursorPos(1,y)if(y==console.height)then term.scroll(1)term.setCursorPos(1,y)else term.setCursorPos(1,y+1)end term.write(max==1 and line or string.sub(line,(console.width*(i-1))+1,console.width*i+1))y=math.min(y+1,console.height)end term.setCursorPos(1,1)term.clearLine()prebounce('term_redraw',console.redraw)console.printLine=y end on('mouse_scroll',function(direction)term.scroll(direction)prebounce('term_redraw',console.redraw)end)console.waitIndicators={[0]='','|','/','-','\\'}console.waitIndex=0 console.nested=0 function console.choice_impl(text,choices,add_space)local results={}for n=1,#choices do local option=choices[n] if #option+(add_space and 1 or 0)>#text and option:sub(1,#text)==text then local result=option:sub(#text+1)if add_space then table.insert(results,result.." ")else table.insert(results,result)end end end return results end function console.read(_sReplaceChar,consoletory,_fnComplete,_sDefault,_nTimeout,_bSpinner)if _sReplaceChar~=nil and type(_sReplaceChar)~="string" then error(string.join({"bad argument #1(expected string,got ",type(_sReplaceChar),")"},''),2)end if consoletory~=nil and type(consoletory)~="table" then error(string.join({"bad argument #2(expected table,got ",type(consoletory),")"},''),2)end if _fnComplete~=nil and type(_fnComplete)~="function" then error(string.join({"bad argument #3(expected function,got ",type(_fnComplete),")"},''),2)end if _sDefault~=nil and type(_sDefault)~="string" then error(string.join({"bad argument #4(expected string,got ",type(_sDefault),")"},''),2)end if _nTimeout~=nil and type(_nTimeout)~="number" and type(_nTimeout)~="function" then error(string.join({"bad argument #5(expected number or function,got ",type(_nTimeout),")"},''),2)end if _bSpinner~=nil and type(_bSpinner)~='boolean' then error(string.join({"bad argument #6(expected boolean,got ",type(_bSpinner),")"},''),2)elseif not _bSpinner then console.waitIndex=0 end term.setCursorBlink(true)console.nested=console.nested+1 local nested=console.nested local sLine='' local nPos=0 _sDefault=_sDefault or "" if _bSpinner and console.waitIndex==0 then console.waitIndex=1 end local nHistoryPos local _sDefaultLength=#(table.concat({console.waitIndicators[console.waitIndex],_sDefault},''))if _sReplaceChar then _sReplaceChar=string.sub(_sReplaceChar,1,1)end local tCompletions local nCompletion local function recomplete()if(console.nested~=nested)then return end if _fnComplete and nPos==string.len(sLine)then tCompletions=_fnComplete(sLine)if tCompletions and #tCompletions>0 then nCompletion=1 else nCompletion=nil end else tCompletions=nil nCompletion=nil end end local function uncomplete()if(console.nested~=nested)then return end tCompletions=nil nCompletion=nil end local w,h=term.getSize()local sx=1 local function redraw(_bClear)if(console.nested~=nested)then return end local nScroll=0 if sx+nPos+_sDefaultLength>=w then nScroll=(sx+nPos+_sDefaultLength)-w end term.setCursorPos(1,1)term.clearLine()local cx,cy=1,1 local sReplace=(_bClear and " ")or _sReplaceChar if sReplace then term.write(string.rep(sReplace,math.max(string.len(sLine)+_sDefaultLength-nScroll,0)))else term.write(string.sub(table.concat({console.waitIndicators[console.waitIndex],_sDefault,sLine},''),nScroll+1))end if nCompletion then local sCompletion=tCompletions[ nCompletion ] local oldText,oldBg if not _bClear then oldText=term.getTextColor()oldBg=term.getBackgroundColor()term.setTextColor(colors.white)term.setBackgroundColor(colors.gray)end if sReplace then term.write(string.rep(sReplace,string.len(sCompletion)))else term.write(sCompletion)end if not _bClear then term.setTextColor(oldText)term.setBackgroundColor(oldBg)end end term.setCursorPos(sx+nPos+_sDefaultLength-nScroll,1)end local function clear()if(console.nested~=nested)then return end redraw(true)end recomplete()redraw()local function acceptCompletion()if nCompletion then clear()local sCompletion=tCompletions[ nCompletion ] sLine=sLine..sCompletion nPos=string.len(sLine)recomplete()redraw()end end local currentTimer=nil local sessionID=math.random(0,1000)local timeoutFunction=nil if(type(_nTimeout)=='function')then local waitFunc=_nTimeout _nTimeout=nil timeoutFunction=add(function()waitUntil(waitFunc)queue('stopconsole',sessionID)end)end function _timer()if(_nTimeout~=nil)then add(function()local ourID=math.random(0,1000)currentTimer=ourID wait(_nTimeout,function()return currentTimer~=ourID end)if(currentTimer==ourID)then queue('stopconsole',sessionID)end end)end end local charListener=on('char',function(char)clear()sLine=string.join({string.sub(sLine,1,nPos),char,string.sub(sLine,nPos+1)},'')nPos=nPos+1 recomplete()redraw()_timer()end)local pasteListener=on('paste',function(paste)clear()sLine=string.join({string.sub(sLine,1,nPos),paste,string.sub(sLine,nPos+1)},'')nPos=nPos+string.len(paste)recomplete()redraw()_timer()end,function()return console.nested==nested end)local ctrlPressed=false local keyListener=on('key',function(key)if key==keys.enter then if(console.nested==nested)then if nCompletion then clear()uncomplete()redraw()end queue('stopconsole',sessionID)else sLine='' nPos=0 end elseif key==keys.left then if nPos>0 then clear()if(ctrlPressed)then local lineStart=string.sub(sLine,1,nPos):reverse()local subStart,subEnd=string.find(lineStart,'^%s*[^%s]*%s*')if(subStart)then nPos=nPos-(subEnd-subStart)-1 end else nPos=nPos-1 end recomplete()redraw()end elseif key==keys.right then if nPos<string.len(sLine)then clear()if(ctrlPressed and(nPos+1)<string.len(sLine))then local _,last=string.find(sLine,'^%s*[^%s]*%s*',nPos+1)nPos=last and(last-1)or nPos if((nPos+1)==string.len(sLine))then nPos=nPos+1 end else nPos=nPos+1 end recomplete()redraw()else acceptCompletion()end elseif key==keys.up or key==keys.down then if nCompletion then clear()if key==keys.up then nCompletion=nCompletion-1 if nCompletion<1 then nCompletion=#tCompletions end elseif key==keys.down then nCompletion=nCompletion+1 if nCompletion>#tCompletions then nCompletion=1 end end redraw()elseif consoletory then clear()if key==keys.up then if nHistoryPos==nil then if #consoletory>0 then nHistoryPos=#consoletory end elseif nHistoryPos>1 then nHistoryPos=nHistoryPos-1 end else if nHistoryPos==#consoletory then nHistoryPos=nil elseif nHistoryPos~=nil then nHistoryPos=nHistoryPos+1 end end if nHistoryPos then sLine=consoletory[nHistoryPos] nPos=string.len(sLine)else sLine='' nPos=0 end uncomplete()redraw()end elseif key==keys.backspace then if nPos>0 then clear()if(ctrlPressed)then local lineStart=string.sub(sLine,1,nPos):reverse()local subStart,subEnd=string.find(lineStart,'^%s*[^%s]*%s*')if(subStart)then local newStart=string.sub(lineStart,subEnd+1):reverse()sLine=string.join({newStart,string.sub(sLine,nPos+1)},'')nPos=#newStart end else sLine=table.concat({string.sub(sLine,1,nPos-1),string.sub(sLine,nPos+1)},'')nPos=nPos-1 end recomplete()redraw()end elseif key==keys.home then if nPos>0 then clear()nPos=0 recomplete()redraw()end elseif key==keys.delete then if nPos<string.len(sLine)then clear()if(ctrlPressed)then local _,last=string.find(sLine,'^%s*[^%s]*%s*',nPos+1)last=last or nPos sLine=string.join({string.sub(sLine,1,nPos),string.sub(sLine,last+1)},'')else sLine=string.join({string.sub(sLine,1,nPos),string.sub(sLine,nPos+2)},'')end recomplete()redraw()end elseif key==keys["end"] then if nPos<string.len(sLine)then clear()nPos=string.len(sLine)recomplete()redraw()end elseif key==keys.tab then acceptCompletion()elseif(key==keys.leftCtrl or key==keys.rightCtrl)then ctrlPressed=true end _timer()end)local keyUpListener=on('key_up',function(key)if(key==keys.leftCtrl or key==keys.rightCtrl)then ctrlPressed=false end _timer()end)local resizeListener=on('term_resize',function()w=term.getSize()if(console.nested==nested)then return end redraw()_timer()end)local redrawListener=on('term_redraw',function()redraw()end,function()return console.nested==nested end)local stopped=false local spinnerAction=_bSpinner and add(function()while(not stopped)do if(console.nested~=nested)then waitUntil(function()return console.nested==nested end)end console.waitIndex=(console.waitIndex % #console.waitIndicators)+1 prebounce('redraw',redraw)wait(0.2)end end)local quitListener=on({event='stopconsole',once=true,filter=function(eSessionID)return eSessionID==sessionID end,f=function()off('char',charListener)off('paste',pasteListener)off('key',keyListener)off('term_resize',resizeListener)off('term_redraw',redrawListener)if(_bSpinner)then off(spinnerAction)end off(timeoutFunction)stopped=true if nCompletion then clear()uncomplete()redraw()end end})_timer()waitUntil(function()return stopped end)local cx,cy=term.getCursorPos()if(console.nested==1)then term.setCursorBlink(false)else prebounce('term_redraw',console.redraw)end if(sLine~="")then term.clearLine()term.setCursorPos(1,1)end console.nested=console.nested-1 console.waitIndex=0 return sLine end function console.redraw()queue('term_redraw')end function console.clear()term.clear()term.setCursorPos(1,1)console.printLine=2 prebounce('term_redraw',console.redraw)end if(websocket==nil)then websocket={}end if(websocket_private==nil)then websocket_private={}end websocket_private.url='localhost:8080' websocket_private.class=class({constructor=function(self,socket,url)self.socket=socket self.url=url self.queue={}self.active=true self.counter=0 end,stop=function(self)self.active=false self.socket=nil end,restart=function(self,socket)self.socket=socket self.active=true end,send=function(self,message)local myCounter=self.counter self.counter=self.counter+1 table.insert(self.queue,myCounter)add(function()waitUntil(function()return self.active and self.queue[1]==myCounter end)self.socket.send(message)tables.removeMany(self.queue,function(t,i)return t[i]==myCounter end)end)end})websocket_private._sockets={}function websocket_private.connect(url)url=string.starts(url,'ws://')and url or 'ws://'..url if(websocket_private._sockets[url]~=nil and websocket_private._sockets[url].active)then return websocket_private._sockets[url] end local socket=nil local successFunc=once('websocket_success',function(_,param)socket=param end,function(fUrl)return url==fUrl end)local failFunc=once('websocket_failure',function(_,err)socket=err end,function(fUrl)return url==fUrl end)once('websocket_closed',function(url,err)log.logWarning('Socket ',url,' was closed: ',(err or 'no reason provided'))if(websocket_private._sockets[url]~=nil)then websocket_private._sockets[url]:stop()end socket='socket closed' end,function(fUrl)return url==fUrl end)http.websocketAsync(url)waitUntil(function()return socket~=nil end)off(successFunc)off(failFunc)local websocketInstance=websocket_private._sockets[url]~=nil and websocket_private._sockets[url] or websocket_private.class:new(socket,url)websocket_private._sockets[url]=websocketInstance if(type(socket)=='string')then log.logVerbose("Socket ",url," failed; ",socket)websocketInstance:stop()else websocketInstance:restart(socket)end return websocketInstance end add(function()websocket=websocket_private.connect(websocket_private.url)while(websocket~=nil)do waitUntil(function()return not websocket.active end)websocket_private.connect(websocket.url)wait(10)end end)if(waiter==nil)then waiter={}end waiter.index=1 waiter.options={enabled=true,console=true,indicators={'|','/','-','\\'},timeout=0.2}function waiter.setOption(name,value)waiter.options[name]=value end function waiter.serve(command,...)local response local quit=false local args={...}local waitFunc=add(function()response={try(command,unpack(args))}quit=true end)waiter.wait(function()return quit end)off(waitFunc)return unpack(response or{})end function waiter.wait(waitFor)if(not waiter.options.enabled)then if(waitFor==nil)then return elseif(type(waitFor)=='function')then waitUntil(waitFor)elseif(type(waitFor)=='number')then wait(waitFor)end return end local timeout=waiter.options.timeout local indicators=waiter.options.indicators local quit=false if(waitFor~=nil)then if(type(waitFor)=='function' and waitFor())then return end add(function()if(type(waitFor)=='number')then wait(waitFor,function()return quit end)else waitUntil(function()return quit or waitFor()end)end quit=true end)end local waitFunc=function()return quit end local waitQuitCommands={'q','quit'}local x,y=term.getCursorPos()while(not quit)do if(waiter.options.console)then local qinput=console.read(nil,nil,nil,'>',waitFunc,true)quit=quit or linq:contains(waitQuitCommands,qinput or '')else term.setCursorPos(1,y)term.clearLine()term.setCursorPos(1,y)term.write(indicators[(waiter.index % #indicators)+1])term.setCursorPos(1,y+1)wait(timeout)waiter.index=waiter.index+1 end end term.setCursorPos(1,y)term.clearLine()waiter.index=waiter.index % #indicators end function receiveRequest(path,actionFunc,timeout)return receive(path,actionFunc,true,timeout)end function receiveResponse(path,actionFunc,timeout)return receive(path,actionFunc,false,timeout)end function _doesPathMatchPattern(path,pathPattern)local pathParts=string.split(path,'/')pathPattern=type(pathPattern)=='table' and pathPattern or string.split(pathPattern,'/')if(#pathParts~=#pathPattern)then return false end for k,v in ipairs(pathParts)do if(pathPattern[k]~='*' and v~=pathPattern[k])then return false end end return true end function receive(path,actionFunc,isRequest,timeout)local filterType=(isRequest or nil==isRequest)and 'REQUEST' or 'RESPONSE' local pathPattern=type(path)=='table' and path or string.split(path,'/')local callbackIntermediary=function(message,sender)actionFunc(message,string.split(message.url,'/'))end local filterFunction=function(sender,message,protocol)return message.type==filterType and _doesPathMatchPattern(message.url,pathPattern)end add(function()waitUntil(function()return state==nil or state.status~='podinitializing' end)network.receiveMany(callbackIntermediary,timeout,filterFunction)end)end if(stateH==nil)then stateH={}end stateH.id=os.getComputerID()state=state or{}stateH.init=function(params)params=params or{}state={id=stateH.id,sid=tostring(stateH.id),name=tostring(stateH.id),status=params.status or 'pending',types=params.types or{},elegibleTypes=params.elegibleTypes or{},spec={location=nil,facing='unknown',action=nil,network=network.addr},config={location={autoUpdate=params.autoUpdateLocation or false}},events={},data={}}return state end stateH.addType=function(newType)if(not linq:contains(state.types,newType))then table.insert(state.types,newType)queue('state_type_added',newType)end end stateH.removeType=function(existingType)if(linq:contains(state.types,existingType))then linq:where(state.types,function(k,v)return v==existingType end):remove()queue('state_type_removed',existingType)end end function stateH.onStateTypeAdded(name,callback)on({event='state_type_added',filter=name and function(t)return t==name end,once=false,f=callback})if(name and linq:contains(state.types,name))then add(function()callback()end)end end stateH.save=function()files.writeJson('state.json',state)end stateH.load=function()state=files.readJson('state.json')return state end receiveRequest('/status',function(request)network.respond(request,state)end)if(chat==nil)then chat={}end chat.commands={}chat.cmd=chat.commands chat.quitCommands={'exit','quit','stop'}chat.interactiveCommands={'clear'}chat.cmd.clear=console.clear chat.cmd['repeat']=function(count,func,...)if(chat.commands[func]==nil)then log.logWarning('no action specified')return end if(tonumber(count)==nil)then log.logWarning('number expected')return end for i=1,count do chat.commands[func](...)end end chat.actualCommands=nil chat.completeCommands=nil function chat.choice_complete(text)if(#text==0)then return{}end return console.choice_impl(text,chat.completeCommands,false)end function chat.add(name,func,opts)if(not opts)then chat.cmd[name]=func else setmetatable(opts,{__call=func})chat.cmd[name]=opts end end chat.history={}chat.maxHistory=20 function chat.run()local history=chat.history local commands=chat.commands if(chat.actualCommands==nil)then chat.actualCommands=linq:select(chat.commands,function(k,v)return k end):join(chat.quitCommands):get()end chat.completeCommands=linq:join(chat.actualCommands,history):get()local text=console.read(nil,history,chat.choice_complete,'>')if(text=='')then return true end if(linq:contains(chat.quitCommands,text))then return false end if(history[#history]~=text)then table.insert(history,text)if(#history>chat.maxHistory)then table.remove(history,1)end end local textParts=string.split(text,' ')local command=table.remove(textParts,1)if(commands[command])then if(linq:contains(chat.interactiveCommands,command))then return true,{commands[command],unpack(textParts)}else return true,{waiter.serve,commands[command],unpack(textParts)}end else log.logWarning('Unknown command ',text)end return true end function chat.runDirectly()local ok,task=chat.run()if(ok and task)then state.status='executing '..(task[1] or '')try(table.unpack(task))state.status='running' end return ok end taskQueue={}add(function()while(true)do waitUntil(function()return #taskQueue>0 end)local task=table.remove(taskQueue,1)state.status='executing '..table.remove(task,1)try(table.unpack(task))state.status='running' end end)receiveRequest('/execute',function(request)print('received /execute')if(chat.cmd[request.body.func])then if(linq:contains(chat.interactiveCommands,request.body.func))then table.insert(taskQueue,{request.body.func,chat.cmd[request.body.func],table.unpack(request.body.params or{})})else table.insert(taskQueue,{request.body.func,waiter.serve,chat.cmd[request.body.func],table.unpack(request.body.params or{})})end end end)receiveRequest('/chat/commands',function(request)local keys={}for k,v in pairs(chat.cmd)do table.insert(keys,k)end network.respond(request,keys)end)if(election==nil)then election={}end election.elections={}function election.startElection(electionType)if(linq:contains(election.elections,electionType))then return false end table.insert(election.elections,electionType)local elected=false local isElegible=linq:contains(state.elegibleTypes,electionType)if(not isElegible)then network.broadcast({type='REQUEST',method='GET',url='/election/'..electionType,body={id=-1,electionType=electionType}})else local candidates=election.lookupCandidates(electionType)if(not linq:any(candidates))then log.logVerbose('No response on election ',electionType,',electing self')if(not linq:contains(state.types,electionType))then stateH.addType(electionType)end network.addAddress(electionType,state.id)network.broadcast({type='REQUEST',method='POST',url='/election/'..electionType..'/elected',body={id=state.id,electionType=electionType}})elected=true queue('elected',{self=true,electionType=electionType,id=state.id})end end table.remove(election.elections,linq:indexOf(election.elections,electionType))return elected end function election.lookupCandidates(electionType)local responses={}local electionUrl='/election/'..electionType receiveResponse(electionUrl,function(okResponse)if(okResponse==nil or okResponse.body.id==nil)then return end table.insert(responses,okResponse.body.id)end,2)network.broadcast({type='REQUEST',method='GET',url=electionUrl,body={id=state.id,electionType=electionType}})wait(2,function()return #responses>0 end)return responses end function election.whenElected(electionType,callbackFunc)add(function()if(linq:contains(state.types,electionType))then callbackFunc()end return on{event="elected",filter=function(election)return election.electionType==electionType and election.self end,f=callbackFunc}end)end receiveRequest('/election/*',function(request,urlParts)local isElegible=linq:contains(state.elegibleTypes,request.body.electionType)if(isElegible and request.body.id<state.id)then network.respond(request,{id=state.id})election.startElection(request.body.electionType)end end)receiveRequest('/election/*/elected',function(request,urlParts)network.clearAddress(request.body.electionType)network.addAddress(request.body.electionType,request.body.id)linq:where(election.elections,request.body.electionType):take(1):remove()if(request.body.id~=state.id)then stateH.removeType(request.body.electionType)end queue('elected',{self=false,electionType=request.body.electionType,id=request.body.id})log.logVerbose(request.body.electionType,' elected: ',request.body.id)end)if(networkHandling==nil)then networkHandling={}end networkHandling.discovery={inProgress=false,lastExecuted=nil,refreshInterval=60,didMyStateChange=false}stateH.onStateTypeAdded(nil,function()networkHandling.discovery.didMyStateChange=true end)networkHandling.updateHandlerRunning=false function networkHandling.discoveryLoop()if(networkHandling.updateHandlerRunning)then return end networkHandling.updateHandlerRunning=true while(linq:contains(state.types,'network'))do wait(networkHandling.discovery.refreshInterval)networkHandling.startNetworkDiscovery()end networkHandling.updateHandlerRunning=false end add(function()for k,typeName in ipairs(state.types)do network.addAddress(typeName,state.id)end network.onNetworkAddressRemoved('network',function(eventObj)if(network.hasModem and not eventObj.anyLeft)then if(not networkHandling.lookup('network'))then election.startElection('network')end end end)stateH.onStateTypeAdded('network',function()networkHandling.discoveryLoop()end)wait(math.random(1,2))if(network.hasModem and not getNetworkMap())then wait(3)networkHandling.startNetworkDiscovery()end if(state.status=='podinitializing')then state.status='pending' end end)function networkHandling.startNetworkDiscovery()log.logVerbose('Start network discovery')if(linq:contains(state.types,'network'))then log.logVerbose('I\'m already network')networkHandling.buildNetworkMap()log.logVerbose('Network discovery done')return end local success=getNetworkMap()if(not success)then election.startElection('network')wait(5,function()return network.hasAddress('network')end)networkHandling.startNetworkDiscovery()end log.logVerbose('network leaders:',string.join(network.getIds('network'),','))log.logVerbose('Network discovery done')end function getNetworkMap()log.logVerbose('getNetworkMap')if(linq:contains(state.types,'network'))then networkHandling.buildNetworkMap()return true end local retries=0 local networkHost=network.getCurrentAddress('network')or networkHandling.lookup('network')while(networkHost~=nil and networkHandling.testPodAlive('network')and retries<5)do retries=retries+1 local networkMapRequest=network.get('network','/network')if(networkMapRequest~=nil and networkMapRequest.body~=nil)then log.logVerbose('Updated network map')networkHandling.updateNetwork(networkMapRequest.body)return true end log.logWarning('Got empty network map,retry in 1 second')network.markAddressDropped(networkHost)wait(1)networkHost=network.getCurrentAddress('network')end return false end function networkHandling.buildNetworkMap()log.logVerbose('Build network map')networkHandling.discovery.inProgress=true local timeout=2 local addressMap={pod={state.id}}for k,typ in ipairs(state.types)do addressMap[typ]=addressMap[typ] or{}table.insert(addressMap[typ],state.id)end receiveResponse('/network/ping',function(response)local newAddr=response.body if(newAddr==nil or type(newAddr)~='table')then return end if(not linq:contains(addressMap.pod,newAddr.id))then table.insert(addressMap.pod,newAddr.id)for k,typ in ipairs(newAddr.types)do addressMap[typ]=addressMap[typ] or{}table.insert(addressMap[typ],newAddr.id)end end end,timeout)network.broadcast({type='REQUEST',method='GET',url='/network/ping'})wait(timeout)local anyChange=networkHandling.discovery.didMyStateChange local seenTypes={}for typ,ids in pairs(addressMap)do table.insert(seenTypes,typ)local existingIds=network.getIds(typ)for k,existingId in ipairs(existingIds)do if(not linq:contains(ids,existingId))then anyChange=true network.removeAddress(typ,existingId)end end for k,newId in ipairs(ids)do if(not linq:contains(existingIds,newId))then anyChange=true network.addAddress(typ,newId)end end end for typ in pairs(network.getAddresses())do if(not linq:contains(seenTypes,typ))then anyChange=true network.clearAddress(typ)end end if(anyChange)then networkHandling.discovery.didMyStateChange=false network.broadcast({type='REQUEST',method='POST',url='/network/update',body=network.getAddresses()})end local anyDuplicateNetworkLeaders=linq:any(addressMap.network or{},function(k,id)return id~=state.id end)if(anyDuplicateNetworkLeaders)then election.startElection('network')end networkHandling.discovery.inProgress=false end function networkHandling.updateNetwork(map)network.update(map)state.spec.network=network.addr end function networkHandling.lookup(name)if(not network.hasModem)then return nil end if(network.hasAddress(name))then return network.getAddress(name)end local responses={}local received=false local url='/network/lookup/'..name receiveResponse(url,function(response)response=response.body if(response==nil or linq:contains(responses,response))then return end table.insert(responses,response)received=true end,2)network.broadcast({type='REQUEST',method='GET',url=url})wait(2,function()return received end)for k,response in ipairs(responses)do if(response==state.id or networkHandling.testPodAlive(response))then network.addAddress(name,response)if(response==state.id and not linq:contains(state.types,name))then stateH.addType(name)end end end return network.getAddress(name)end function networkHandling.testPodAlive(address)if(address==nil)then return false end local health=network.get(address,'/health',nil,nil,2)return health~=nil end receiveRequest('/health',function(request)network.respond(request,true)end)receiveRequest('/network',function(request)local condition=function()return not networkHandling.discovery.inProgress end wait(5,condition)if(condition())then network.respond(request,network.getAddresses())end end)receiveRequest('/network/update',function(request)networkHandling.updateNetwork(request.body)end)receiveRequest('/network/lookup/*',function(request,urlParts)waitUntil(function()return not networkHandling.discovery.inProgress end)local r=network.getAddress(urlParts[3])if(r~=nil and r.id~=nil)then network.respond(request,r.id)end end)receiveRequest('/network/ping',function(request)network.respond(request,{types=state.types,id=state.id})debounce('/network/ping',function()election.startElection('network')end,networkHandling.discovery.refreshInterval*3+1)end)election.whenElected('network',function()networkHandling.buildNetworkMap()end)log.setLoglevel('information')log.logInformation("V2.2")log.logInformation("I am ",os.getComputerID())if(not stateH.load())then stateH.init({types={'mobile'},elegibleTypes={'mobile'}})end function updateHandheld()waiter.wait(function()return state.status~='podinitializing' end)log.logVerbose('Loading handheld.lua file from cache...')local response=waiter.serve(function()local retries=0 local value=network.get('cache','/luacache')while(retries<6 and(value==nil or type(value)~='table'))do retries=retries+1 wait(value==false and 10 or 0.5)value=network.get('cache','/luacache')end return value end)if(response~=nil and type(response)=='table')then local responseFile=linq:where(response.body,function(k,v)return v.name=='handheld.lua' end):first()if(responseFile==nil)then error('File from cache was nil')end log.logVerbose('Found handheld.lua file from cache')files.write('startup.lua',responseFile.content)log.logWarning('Rebooting...')waiter.wait(2)os.reboot()else log.logWarning('Cache server did not respond')end end chat.cmd.button=function()local isBlue=false local toggl=function(btn,x,y)if(x~=5 or y~=5)then return end local cx,cy=term.getCursorPos()local clr=term.getBackgroundColor()term.setCursorPos(x,y)term.setBackgroundColor(isBlue and colors.blue or colors.yellow)term.write(' ')term.setBackgroundColor(clr)term.setCursorPos(cx,cy)isBlue=not isBlue end toggl(nil,5,5)on{event="mouse_click",once=false,f=toggl}end chat.cmd.network=function(input)print(network.printAddresses())end chat.cmd.location=function(input)log.logInfo('Current location: ')log.logInfo(waiter.serve(function()return gpsi.locate()end))end chat.cmd.facing=function(input)log.logInfo('Currently facing: ',state.spec.facing)end chat.cmd.tome=function(input)network.broadcast({type='REQUEST',method='POST',url='/pods/moveto',body=gpsi.locate()+Location:new(0,0,-1)})end chat.cmd.mine=function(input)network.broadcast({type='REQUEST',method='POST',url='/pods/mine',body={w=3,h=3}})end chat.cmd.reset=function(input)network.broadcast({type='REQUEST',method='POST',url='/reset',body={}})end table.insert(chat.interactiveCommands,'do')chat.cmd['do']=function(target)console.clear()network.printAddresses()target=target and tonumber(target)or tonumber(console.read(nil,nil,nil,'enter target>>',nil,false))if(target==nil)then return end console.clear()local drawerTask=add(function()while(true)do wait(1)local response=network.get(target,'/status')local tState=response.body if(tState~=nil)then console.clear()print('Name:',tState.name)print('Status:',tState.status)print('Types:',table.unpack(tState.types))else print('Unknown state')end end end)while(true)do local text=console.read(nil,nil,nil,target..'>>',nil,false)if(text=='quit' or text=='exit' or text=='q')then break end local parts=string.split(text,' ')local func,params=table.remove(parts,1),parts network.send({type='REQUEST',method='POST',url='/execute',body={func=func,params=params}},target)end off(drawerTask)end chat.cmd.update=updateHandheld run(function()while(chat.runDirectly())do stateH.save()end end)
