print('10/12/2024 08:35:47')
         if(method==nil)then method={}end local native_select,native_type=select,type local function get_type_names(...)local types=table.pack(...)for i=types.n,1,-1 do if types[i]=="nil" then table.remove(types,i)end end if #types<=1 then return tostring(...)else return table.concat(types,",",1,#types-1).." or "..types[#types] end end function method.expect(index,value,...)local t=native_type(value)for i=1,native_select("#",...)do if t==native_select(i,...)then return value end end local name local ok,info=pcall(debug.getinfo,3,"nS")if ok and info.name and info.name~="" and info.what~="C" then name=info.name end local type_names=get_type_names(...)if name then error(("bad argument #%d to '%s'(expected %s,got %s)"):format(index,name,type_names,t),3)else error(("bad argument #%d(expected %s,got %s)"):format(index,type_names,t),3)end end if(class==nil)then class={}end class=function(classDef,parentClass)if classDef.super or classDef.new or classDef.is then error("super and new can not exist within class defenitions",2)end if parentClass then setmetatable(classDef,{__index=parentClass})classDef.super=parentClass end function classDef:new(...)local new={}setmetatable(new,{__index=self})if new.constructor then new:constructor(...)end return new end function classDef:is(c)local selfTable=getmetatable(self)local cTable=getmetatable(c)return(selfTable~=nil and c==selfTable.__index)or(cTable~=nil and self==cTable.__index)end return classDef end if(convert==nil)then convert={}end function convert.toJson(message)return textutils.serialise(message)end function convert.fromJson(message)if(type(message)=="table")then return message end if(type(message)=="string")then return textutils.unserialise(message)end return nil end function convert.isJson(message)local json=convert.fromJson(message)return json~=nil,json end function convert.toLocation(loc,y,z)local location={}if(loc==nil)then return location end if(type(loc)=="table")then location.x=tonumber(loc.x)or tonumber(loc[1])or 0 location.y=tonumber(loc.y)or tonumber(loc[2])or 0 location.z=tonumber(loc.z)or tonumber(loc[3])or 0 else location.x=tonumber(loc)or 0 location.y=tonumber(y)or 0 location.z=tonumber(z)or 0 end location[1]=location.x location[2]=location.y location[3]=location.z return location end if(files==nil)then files={}end function files.write(name,content)local file=fs.open(name,"wb")file.write(content)file.close()end function files.read(name)if(not fs.exists(name))then return nil end local file=fs.open(name,"r")local contents=file.readAll()file.close()return contents end function files.writeJson(name,content)return files.write(name,textutils.serialiseJSON(content))end function files.readJson(name)local content=files.read(name)return content and textutils.unserialiseJSON(content)or nil end if(var==nil)then var={}end var.sides={"right","left","up","down","front","back"}var.directions={"north","east","south","west"}if(try==nil)then try={}end try=setmetatable(try,{__call=function(self,func,...)local result={pcall(func,...)}if(table.remove(result,1))then return unpack(result)else print('ERR','try()',result[1])end end})function try.catch(startFunc,catchFunc)local result={pcall(startFunc)}if(table.remove(result,1))then return unpack(result)else catchFunc(result[1])end end function string.starts(String,Start)return string.sub(String,1,string.len(Start))==Start end function string.before(String,Start)return string.sub(String,1,string.len(Start))end function string.after(String,Start)return string.sub(String,string.len(Start)+1)end function string.split(inputstr,sep)if sep==nil then sep="." end local t={}for str in string.gmatch(inputstr,"([^"..sep.."]+)")do table.insert(t,str)end return t end function string.trim(s)return(string.gsub(s,"^%s*(.-)%s*$","%1"))end function string.join(params,glue)if(#params==1)then return tostring(params[1])end glue=glue or '.' local t={}for k,v in ipairs(params)do t[#t+1]=tostring(v)end return table.concat(t,glue)end function firstToUpper(str)return(str:gsub("^%l",string.upper))end Responder={}Responder.__index=Responder if(Responder==nil)then Responder={}end function Responder:new(functionToWrap)assert(self,"missing receiver")local r=setmetatable({},self)r.func=functionToWrap r.co=coroutine.create(r.func)if(r.co==nil)then error('Could not create new responder')end return r end function Responder:__call(...)if self:canResume()then local response={coroutine.resume(self.co,...)}if(not response[1])then print('ERR: in Responder:__call')print(response[2])end table.remove(response,1)if(type(response[1])=='function')then self.check=response[1] table.remove(response,1)end return true,response else return false end end function Responder:stop()self.co=nil end function Responder:finished()return self.co==nil or coroutine.status(self.co)=="dead" end function Responder:canResume()if not self:finished()then if self.check then return self:check()else return true end end return false end if(Location==nil)then Location={}end Location.isLocation=true function Location:__eq(other)return type(other)=='table' and other.isLocation and other.x==self.x and other.y==self.y and other.z==self.z end function Location:__add(other)if(type(other)~='table' or not other.isLocation)then error('Can not add Location to type '..type(other))end return Location:new(other.x+self.x,other.y+self.y,other.z+self.z)end function Location:__sub(other)if(type(other)~='table' or not other.isLocation)then error('Can not sub Location from type '..type(other))end return Location:new(self.x-other.x,self.y-other.y,self.z-other.z)end function Location:__tostring()return "X:"..self.x.." Y:"..self.y.." Z:"..self.z end function Location:new(x,y,z)if(type(x)=='table')then if(#x<3)then error('Expected the first argument of Location:new to be a table with 3 elements')end z=x.z or x[3] y=x.y or x[2] x=x.x or x[1] end o={x=x or 1,y=y or 1,z=z or 1,x or 1,y or 1,z or 1}setmetatable(o,self)self.__index=self return o end function Location:distance2d(other)local diff=self-other return math.abs(diff.x)+math.abs(diff.y)end if(linq==nil)then linq={}end if(_linq==nil)then _linq={}end function _linq._iterator(self,iteratorfunc)for i,keyvalue in ipairs(self.cache)do coroutine.yield(keyvalue[1],keyvalue[2],i)end local i=#self.cache+1 if(not self.done and self.parent~=nil)then local pIterator=self.parent.getIterator()local pDone,pKey,pValue=pIterator()while(not pDone and pKey~=nil and not self.done)do if(self.filter==nil or self.filter(pKey,pValue,i,self))then if(iteratorfunc)then pKey,pValue=iteratorfunc(pKey,pValue,i,self)end self.cache[i]={pKey,pValue}coroutine.yield(pKey,pValue,i)i=i+1 end pDone,pKey,pValue=pIterator()end end if(not self.done and self.data)then for k,v in pairs(self.data)do if(not self.done and self.filter==nil or self.filter(k,v,i,self))then if(iteratorfunc)then k,v=iteratorfunc(k,v,i,self)end self.cache[i]={k,v}coroutine.yield(k,v,i)i=i+1 end end end end function _linq._wrap(func)local co=Responder:new(func)return function(...)_,response=co()if(not co:canResume())then return true end if(type(response)~='table')then error('expected table')end response=response or{}return false,response[1],response[2] end end linq=class({constructor=function(self,params)self.new=nil self.isLinq=true local data,filter,iterator,parent=params.data,params.filter,params.iterator,params.parent self.getIterator=function()return _linq._wrap(function()if(iterator)then iterator(self)else _linq._iterator(self)end self.done=true end)end if(type(filter)=='string' or type(filter)=='number')then filter=function(k,v)return v==filter end end self.filter=filter self.cache={}self.data=data self.parent=parent end,cache=nil,data=nil,done=false,filter=nil,parent=nil,isLinq=false,newSubQuery=function(self,params)params.parent=self return linq:new(params)end})function linq:where(data,func)if(func~=nil)then return linq:new({data=data,filter=func})else func=data return self:newSubQuery({filter=func})end end function linq:take(data,count)if(count~=nil)then return linq:new({data=data,filter=function(k,v,i,self)self.done=i==count return k<=count end})else count=data return self:newSubQuery({filter=function(k,v,i,self)self.done=i==count return i<=count end})end end function linq:skip(data,count)if(count~=nil)then count=count+1 return linq:new({data=data,filter=function(k,v,i)count=count-1 return k>count end})else count=data+1 return self:newSubQuery({filter=function(k,v,i)count=count-1 return k>count end})end end function linq:join(dataA,dataB)if(dataB==nil)then dataA,dataB=self,dataA if(not dataA.isLinq)then error('linq:join expected two arguments')end end if(dataA.isLinq)then if(dataB.isLinq)then return linq:new({iterator=function()_linq._iterator(dataA)_linq._iterator(dataB)end})else return self:newSubQuery({data=dataB})end else return linq:new({parent=linq:new({data=dataA}),data=dataB})end end function linq:reverse()local oldSelf=self return linq:new({iterator=function(self)self.data={}local tempData={}oldSelf:each(function(k,v)table.insert(tempData,{k,v})end)local y=1 for i=#tempData,1,-1 do self.data[y]=tempData[i] y=y+1 end tempData=nil _linq._iterator(self,function(key,value)return value[1],value[2] end)end})end function linq:getSorted(data,func)if(data==nil)then return linq:getSorted(self:get())elseif(func==nil)then table.sort(data)return data elseif(type(func)=='function')then table.sort(data,func)return data else print('linq:sort','unknown arguments',data,func)end end function linq:get()local data={}local iterator=self.getIterator()local pDone,pKey,pValue=iterator()while(not pDone)do table.insert(data,pValue)pDone,pKey,pValue=iterator()end return data end function linq:first(data)if(data==nil)then local iterator=self.getIterator()local pDone,pKey,pValue=iterator()return not pDone and pValue else for k,v in pairs(data)do return v end end end function linq:last()local iterator=self.getIterator()local pDone,pKey,pValue=iterator()local last=pValue while(not pDone)do last=pValue pDone,pKey,pValue=iterator()end return last end function linq:_cache()local iterator=self.getIterator()while(not iterator())do end end function linq:any(data,funcOrData)if(data==nil)then local iterator=self.getIterator()local pDone=iterator()return not pDone elseif(type(funcOrData)=='function')then for k,v in pairs(data)do if(funcOrData(k,v))then return true end end return false elseif(funcOrData~=nil)then for k,v in pairs(data)do if(v==funcOrData)then return true end end return false elseif(type(data)=='table')then for k,v in pairs(data)do return true end return false else return self:where(data):any()end end linq.contains=linq.any function linq:each(data,func)if(func==nil)then func=data return self:newSubQuery({iterator=function(self)_linq._iterator(self,func)end}):get()else return linq:new({data=data,iterator=function(self)_linq._iterator(self,func)end}):get()end end function linq:select(data,func)if(func==nil)then func=data return self:newSubQuery({iterator=function(self)_linq._iterator(self,function(k,v)return k,func(k,v)end)end})else return linq:new({data=data,iterator=function(self)_linq._iterator(self,function(k,v)return k,func(k,v)end)end})end end linq.map=linq.select function linq:remove()local function getData(linqItem)if(linqItem.parent~=nil)then return getData(linqItem.parent)end return linqItem.data end local data=getData(self)self:reverse():each(function(k,v)table.remove(data,k)end)end function linq:indexOf(data,obj)if(obj==nil)then obj=data return self:where(function(k,v)return v==obj end):select(function(k)return k end):first()else return linq:new({data=data}):indexOf(obj)end end if(tables==nil)then tables={}end function tables.removeMany(t,fnRemove)if(fnRemove==nil)then return t end local typ=type(fnRemove)local j,n=1,#t if(typ=='function')then for i=1,n do if(fnRemove(t,i,j))then t[i]=nil; else if(i~=j)then t[j]=t[i]; t[i]=nil; end j=j+1; end end else for i=1,n do if(t[i]==fnRemove)then t[i]=nil; else if(i~=j)then t[j]=t[i]; t[i]=nil; end j=j+1; end end end if(#t>j)then n=#t for i=j,n do if(t[i]~=nil)then if(i~=j)then t[j]=t[i]; t[i]=nil; end j=j+1; end end end return t; end function tables.iShallowCopy(t)if(#t==0)then return t end local t2={}for k,v in ipairs(t)do t2[k]=v end return t2 end function tables.deepCopy(t)local t2={}for k,v in pairs(t)do if(type(v)=='table')then t2[k]=tables.deepCopy(v)else t2[k]=v end end return t2 end function tables.immutableInsert(t,item,index)index=index or(#t+1)local newT=tables.iShallowCopy(t)table.insert(newT,index,item)return newT end function tables.sortBy(t,property)table.sort(t,function(a,b)return a[property]<b[property] end)return t end function tables.sortByDescending(t,property)table.sort(t,function(a,b)return a[property]>b[property] end)return t end tables.sortByAscending=tables.sortBy if(positions==nil)then positions={}end function positions.calcFacingStartStop(start,stop)if(not start.isLocation or not stop.isLocation)then error('Requires Locations as input types')end if(start==stop)then return "unknown","unknown" end local xDiff=start.x-stop.x local yDiff=start.y-stop.y local xD=xDiff>0 and "west" or(xDiff<0)and "east" or "" local yD=yDiff>0 and "north" or(yDiff<0)and "south" or "" local function combineDirection()if(xD~="" and yD~="")then return string.join({yD,xD},'-')end return yD..xD end if(math.abs(xDiff)>math.abs(yDiff))then return xD,combineDirection()elseif(math.abs(xDiff)<math.abs(yDiff))then return yD,combineDirection()end return xD,combineDirection()end function positions.reverseDirection(dir)if(dir=='north')then return 'south' elseif(dir=='east')then return 'west' elseif(dir=='south')then return 'north' elseif(dir=='west')then return 'east' end return 'unknown' end if(log==nil)then log={}end loglevel=settings.get('loglevel')or 3 function log.setLoglevel(level)if(type(level)=="string")then if(level=="error")then loglevel=4 end if(level=="warning")then loglevel=3 end if(level=="info" or level=="information")then loglevel=2 end if(level=="verbose")then loglevel=1 end settings.set("loglevel",loglevel)elseif(type(level)=="number")then loglevel=level settings.set("loglevel",level)end end function log._log(filter,...)if(loglevel<=filter)then print(string.join({...},''))return true else return false end end function log.logError(...)return log._log(4,...)end function log.logWarning(...)return log._log(3,...)end function log.logInformation(...)return log._log(2,...)end function log.logVerbose(...)return log._log(1,...)end function log.bool(boolean)return boolean and 'true' or 'false' end log.logInfo=log.logInformation if(rx==nil)then rx={}end function rx.errorWrapper(f,name,errType)return function(...)local ok,err=pcall(f,...)if(not ok)then print('ERR:',errType or '',name or '')print(err)end end end EventTable={}EventTable.__index=EventTable function EventTable:on(optsOrName,f)local opts if type(optsOrName)=="table" then opts=optsOrName else opts={event=optsOrName,f=f}end local name=opts.event assert(type(name)=="string" and name~="",":on requires an event name")assert(type(opts.f)=="function",":on requires an event handler")if(opts.handler)then opts.fWrapped=opts.handler else opts.fWrapped=rx.errorWrapper(opts.f,name,'EVENT')end self[name]=self[name] or{}table.insert(self[name],opts)return opts.f end function EventTable:off(name,responder)if responder and self[name] then tables.removeMany(self[name],function(t,i)return t[i].f==responder end)elseif(type(name)=='string')then self[name]=nil elseif(type(name)=='function')then if(self['timer'])then tables.removeMany(self['timer'],function(t,i)return t[i].f==name end)end tables.removeMany(self._unfinishedResponders,function(t,i)return t[i].func==name end)end end function EventTable:dispatch(name,...)if(self[name]==nil or #self[name]==0)then return false end local sent=false local args={...}tables.removeMany(self[name],function(t,i)local responder=t[i] if type(responder.filter)=="function" and not responder.filter(table.unpack(args))then return false else local f,ok,fResult if(responder.handler)then f=responder.handler ok,fResult=f(name,table.unpack(args))else f=Responder:new(responder.fWrapped)ok,fResult=f(table.unpack(args))end sent=true if not f:finished()then if(type(fResult)=='table' and type(fResult[1])=='string')then local event,filter=fResult[1],fResult[2] if(responder.handler and name==event)then responder.filter=type(filter)=='function' and filter return false else self:on({event=event,handler=f,f=responder.f,filter=type(filter)=='function' and filter,once=false})end else self:addResponder(f)end end return responder.handler~=nil or responder.once end end)return sent end function EventTable:addResponder(responder)table.insert(self._unfinishedResponders,responder)end function EventTable:resume()local newUnfinishedResponders={}for _,responder in ipairs(self._unfinishedResponders)do local ok,fResult=responder()if not responder:finished()then if(type(fResult)=='table' and type(fResult[1])=='string')then self:on({event=fResult[1],handler=responder,f=responder.func,filter=type(fResult[2])=='function' and fResult[2],once=false})else table.insert(newUnfinishedResponders,responder)end end end self._unfinishedResponders=newUnfinishedResponders end function EventTable:new()assert(self,"missing receiver")local et=setmetatable({},self)et._unfinishedResponders={}return et end local osEvents=EventTable:new()function on(...)return osEvents:on(...)end function off(...)return osEvents:off(...)end function add(func)local responder=Responder:new(rx.errorWrapper(func,'add'))osEvents:addResponder(responder)return responder.func end function queue(...)os.queueEvent(...)end function waitUntil(checkFunc)if(not checkFunc())then coroutine.yield(checkFunc)end end function once(event,func,filter)if(type(event)=='table')then local opts=event event=opts.event func=opts.f or opts.func filter=opts.filter end return on{event=event,filter=filter,once=true,f=func}end function wait(seconds,cancelFunction)local ourID=os.startTimer(seconds)if(cancelFunction~=nil)then local fired=false local onListener=on{event="timer",filter=function(timerID)return timerID==ourID or fired end,once=true,f=function()fired=true end}waitUntil(function()return fired or cancelFunction()end)off('timer',onListener)os.cancelTimer(ourID)else coroutine.yield('timer',function(id)return id==ourID end)end end function waitForEvent(event,filter)return coroutine.yield(event,filter)end rx.debouncers={}function debounce(name,func,timeout)rx.debouncers[name]=rx.debouncers[name] or{}local db=rx.debouncers[name] if(timeout)then if(db.id)then os.cancelTimer(db.id)off('timer',db.on)end db.id=os.startTimer(timeout)db.on=on{event="timer",filter=function(timerID)return timerID==db.id end,once=true,f=function()rx.debouncers[name]=nil func()end}else if(db.on)then off(db.on)end db.on=add(function()rx.debouncers[name]=nil func()end)end end function run(mainFunction)mainFunction=mainFunction or function()while(true)do wait(10)end end if mainFunction then ok,err=pcall(add,function()mainFunction()quit()end)if(not ok)then print('run err')print(err)end ok,err=pcall(osEvents.resume,osEvents)if(not ok)then print('run err2')print(err)end end while true do local event={os.pullEventRaw()}local eventName=event[1] local handled=osEvents:dispatch(unpack(event))if not handled then if eventName=="terminate" then print("Shutting down")break end end osEvents:resume()end end function quit()queue('terminate')end if(gpsi==nil)then gpsi={}end CHANNEL_GPS=65534 CHANNEL_REPLY=51933 function gpsi.trilaterate(A,B,C)local a2b=B.vPosition-A.vPosition local a2c=C.vPosition-A.vPosition if math.abs(a2b:normalize():dot(a2c:normalize()))>0.999 then return nil end local d=a2b:length()local ex=a2b:normalize()local i=ex:dot(a2c)local ey=(a2c-ex*i):normalize()local j=ey:dot(a2c)local ez=ex:cross(ey)local r1=A.nDistance local r2=B.nDistance local r3=C.nDistance local x=(r1*r1-r2*r2+d*d)/(2*d)local y=(r1*r1-r3*r3-x*x+(x-i)*(x-i)+j*j)/(2*j)local result=A.vPosition+ex*x+ey*y local zSquared=r1*r1-x*x-y*y if zSquared>0 then local z=math.sqrt(zSquared)local result1=result+ez*z local result2=result-ez*z local rounded1,rounded2=result1:round(0.01),result2:round(0.01)if rounded1.x~=rounded2.x or rounded1.y~=rounded2.y or rounded1.z~=rounded2.z then return rounded1,rounded2 else return rounded1 end end return result:round(0.01)end function gpsi.narrow(p1,p2,fix)local dist1=math.abs((p1-fix.vPosition):length()-fix.nDistance)local dist2=math.abs((p2-fix.vPosition):length()-fix.nDistance)if math.abs(dist1-dist2)<0.01 then return p1,p2 elseif dist1<dist2 then return p1:round(0.01)else return p2:round(0.01)end end function gpsi.locate(_nTimeout,_bDebug)method.expect(1,_nTimeout,"number","nil")method.expect(2,_bDebug,"boolean","nil")if commands then return commands.getBlockPosition()end local sModemSide=nil for _,sSide in ipairs(rs.getSides())do if peripheral.getType(sSide)=="modem" and peripheral.call(sSide,"isWireless")then sModemSide=sSide break end end if sModemSide==nil then if _bDebug then log.logWarning("No wireless modem attached")end return nil end if _bDebug then log.logVerbose("Finding position...")end local modem=peripheral.wrap(sModemSide)local bCloseChannel=false if not modem.isOpen(CHANNEL_REPLY)then modem.open(CHANNEL_REPLY)bCloseChannel=true end modem.transmit(CHANNEL_GPS,CHANNEL_REPLY,"PING")local tFixes={}local pos1,pos2=nil,nil local done=false local onModemMessage=function(sSide,sChannel,sReplyChannel,tMessage,nDistance)if sSide==sModemSide and sChannel==CHANNEL_REPLY and sReplyChannel==CHANNEL_GPS and nDistance then if type(tMessage)=="table" and #tMessage==3 and tonumber(tMessage[1])and tonumber(tMessage[2])and tonumber(tMessage[3])then local tFix={vPosition=vector.new(tMessage[1],tMessage[2],tMessage[3]),nDistance=nDistance}if _bDebug then log.logVerbose(tFix.nDistance," metres from ",tostring(tFix.vPosition))end if tFix.nDistance==0 then pos1,pos2=tFix.vPosition,nil else table.insert(tFixes,tFix)if #tFixes>=3 then if not pos1 then pos1,pos2=gpsi.trilaterate(tFixes[1],tFixes[2],tFixes[#tFixes])else pos1,pos2=gpsi.narrow(pos1,pos2,tFixes[#tFixes])end end end if pos1 and not pos2 then done=true end end end end on('modem_message',onModemMessage)wait(_nTimeout or 2,function()return done end)off('modem_message',onModemMessage)if bCloseChannel then modem.close(CHANNEL_REPLY)end if pos1 and pos2 then if _bDebug then log.logVerbose("Ambiguous position")log.logVerbose("Could be ",pos1.x,",",pos1.y,",",pos1.z," or ",pos2.x,",",pos2.y,",",pos2.z)end return nil elseif pos1 then if _bDebug then log.logVerbose("Position is ",pos1.x,",",pos1.y,",",pos1.z)end return Location:new(math.floor(pos1.x),math.floor(pos1.y),math.floor(pos1.z))else if _bDebug then log.logVerbose("Could not determine position")end return nil end end if(twrap==nil)then twrap={}end function twrap.wrapRepeat(action,times)times=times or 1 if(times>0)then for i=2,times do action()end return action()end end function twrap.whileTrue(action)local result=action()while(result)do result=action()end return result end function twrap.right(i)i=(i or 1)% 4 if(i==1)then return turtle.turnRight()elseif(i==2)then return twrap.wrapRepeat(turtle.turnRight,i)elseif(i==3)then return turtle.turnLeft()end end function twrap.left(i)i=(i or 1)% 4 if(i==1)then return turtle.turnLeft()elseif(i==2)then return twrap.wrapRepeat(turtle.turnLeft,i)elseif(i==3)then return turtle.turnRight()end end twrap.turnRight=twrap.right twrap.turnLeft=twrap.left function twrap.turnAround()return twrap.right(2)end function twrap.forward(i)return twrap.wrapRepeat(turtle.forward,i)end function twrap.back(i)return twrap.wrapRepeat(turtle.back,i)end function twrap.up(i)return twrap.wrapRepeat(turtle.up,i)end function twrap.down(i)return twrap.wrapRepeat(turtle.down,i)end function twrap.dig()return twrap.whileTrue(turtle.dig)end function twrap.digUp()return twrap.whileTrue(turtle.digUp)end function twrap.digDown()return twrap.whileTrue(turtle.digDown)end if(turtle~=nil)then for k,v in pairs(turtle)do if(k~='native' and twrap[k]==nil)then twrap[k]=v end end end if(network==nil)then network={}end network.addr={}network.senderID=os and os.getComputerID()or 0 network.protocol="BIFORMATION.PLAIN.V2" network.queueUpdates=true network.hasModem=peripheral.find('modem')~=nil add(function()on({event='peripheral',filter=function(side)return peripheral.getType(side)=='modem' end,once=false,f=function()network.hasModem=peripheral.find('modem')~=nil if(network.hasModem)then network.open()end end})on({event='peripheral_detach',once=false,f=function()network.hasModem=peripheral.find('modem')~=nil end})end)rednet.CHANNEL_BROADCAST=51932 local cAddress=class({constructor=function(self,name,id)self.name=name self.id=id self.dropped=0 end})function network.getIds(name)return network.hasAddress(name)and linq:select(network.addr[name].points,function(key,value)return value.id end):get()or{}end function network.getAddresses()return network.addr end function network.hasAddress(name)return network.addr[name]~=nil and linq:any(network.addr[name].points)end function network.printAddresses()for typ,adr in pairs(network.addr)do log.logInformation(typ,':',string.join(linq:select(adr.points,function(key,value)return value.id end):getSorted(),','))end end function network.getCurrentAddress(name)if(not network.hasAddress(name))then return nil end local address=network.addr[name] address.pointer=((address.pointer-1)% #address.points)+1 return address.points[address.pointer] end function network.getAddress(name)if(not network.hasAddress(name))then return nil end network.addr[name].pointer=(network.addr[name].pointer % #network.addr[name].points)+1 return network.getCurrentAddress(name)end function network.addAddress(name,id)if(not network.hasAddress(name))then network.addr[name]={points={},pointer=0}end if(not linq:where(network.addr[name].points,function(k,v)return v.id==id end):any())then table.insert(network.addr[name].points,cAddress:new(name,id))if(network.queueUpdates)then queue('network_address_added',{name=name,id=id})end end end function network.removeAddress(name,id)if(not network.hasAddress(name))then return nil end linq:where(network.addr[name].points,function(k,v)return v.id==id end):take(1):remove()if(network.queueUpdates)then queue('network_address_removed',{name=name,id=id,anyLeft=network.hasAddress(name)})end end function network.clearAddress(name)if(not network.hasAddress(name))then return nil end if(network.queueUpdates)then local addressIds=linq:select(network.addr[name].points,function(key,value,i)return value.id end):get()for k,id in ipairs(addressIds)do queue('network_address_removed',{name=name,id=id,anyLeft=false})end end network.addr[name]=nil end function network.clearAddresses()if(network.queueUpdates)then for name,addr in pairs(network.addr)do local addressIds=linq:select(addr.points,function(key,value,i)return value.id end):get()for k,id in ipairs(addressIds)do queue('network_address_removed',{name=name,id=id,anyLeft=false})end end end network.addr={}end function network.targetToAddress(target)local address if(type(target)=='table' and cAddress:is(target))then address=target elseif(type(target)=='string')then address=network.getAddress(target)end return address~=nil,address end function network.markAddressDropped(address)if(not cAddress:is(address))then return end address.dropped=address.dropped+1 if(address.dropped>2)then network.removeAddress(address.name,address.id)end end function network.markAddressReceived(address)if(not cAddress:is(address))then return end address.dropped=0 end function network.onNetworkAddressAdded(name,callback)on({event='network_address_added',filter=function(obj)return obj.name==name end,once=false,f=callback})if(network.hasAddress(name))then add(function()callback()end)end end function network.onNetworkAddressRemoved(name,callback)on({event='network_address_removed',filter=function(obj)return obj.name==name end,once=false,f=callback})if(not network.hasAddress(name))then add(function()callback({name=name,id=-1,anyLeft=false})end)end end function network.open(side)if(not network.hasModem)then return false end if(rednet.isOpen())then return true end if(side~=nil)then pcall(rednet.open,side)else local i=1 while(not rednet.isOpen()and i<=#var.sides)do pcall(rednet.open,var.sides[i])i=i+1 end end local isOpen=rednet.isOpen()if(isOpen)then log.logVerbose("Connected to network")else log.logWarning("Failed to connect to network")end return isOpen end function network.receive(timeout,filter,identifier)local receiveFilter=function(sender,message,protocol)return protocol==network.protocol and(filter and filter(sender,message,protocol))end local senderId,message,protocol if(timeout==nil)then senderId,message,protocol=coroutine.yield('rednet_message',receiveFilter)else local ourID=os.startTimer(timeout)local response=nil local handler=on({event='rednet_message',filter=receiveFilter,once=true,f=function(fSenderId,FMessage,fProtocol)response={fSenderId,FMessage,fProtocol or '_'}queue('timer',ourID)end})coroutine.yield('timer',function(id)return id==ourID end)if(response)then os.cancelTimer(ourID)senderId,message,protocol=unpack(response)else off('rednet_message',handler)end end if(senderId~=nil)then log.logVerbose("Received message from #",senderId,' for ',identifier or message.url)return message,senderId else log.logVerbose("Received no ",identifier or(message and message.url),"message within ",(timeout or-1)," seconds")return nil,nil end end function network.receiveMany(callback,timeout,filter,identifier)identifier=identifier or '' local eventHandler=on({event='rednet_message',filter=function(sender,message,protocol)return protocol==network.protocol and(filter==nil or filter(sender,message,protocol))end,once=false,f=function(sender,message,protocol)callback(message,sender)end})if(timeout~=nil)then wait(timeout)log.logVerbose("Network ",identifier,"receiver timed out")off('rednet_message',eventHandler)end end function network.broadcast(message)method.expect(1,message,'table')if(not network.open())then return nil end message.type=message.type or 'REQUEST' message.headers=message.headers or{}message.headers.sender=network.senderID message.headers.corID=message.headers.corID or math.random(0,9999)log.logVerbose("Broadcasting ",(message.url or "")," to network")return rednet.broadcast(message,network.protocol)end function network.send(message,receiver)method.expect(1,message,'table')method.expect(2,receiver,'number')if(not network.open())then return nil end message.headers=message.headers or{}message.headers.sender=network.senderID message.headers.corID=message.headers.corID or math.random(0,9999)log.logVerbose("Send to #",receiver,' at ',message.url)return rednet.send(receiver,message,network.protocol)end function network.respond(request,response)network.send({type='RESPONSE',url=request.url,method=request.method,headers={request=request,corID=request.headers.corID},body=response},request.headers.sender)end function network.get(...)return network._send('GET',...)end function network.post(...)return network._send('POST',...)end function network.put(...)return network._send('PUT',...)end function network._send(method,target,url,headers,body,timeout)local ok,address=network.targetToAddress(target)if(ok)then target=address.id end if(type(target)~='number')then log.logError("network.targetToAddress failed",type(target))return false end local message={type='REQUEST',method=method,url=url,headers=headers or{},body=body or{}}network.send(message,target)local responseMessage,responseSender=network.receive(timeout or 10,function(sender,received,protocol)return received.type=='RESPONSE' and received.headers.corID==message.headers.corID end)return responseMessage end if(polly==nil)then polly={}end polly.retry=function(funcToRetry,funcStopCondition,delay)funcToRetry()while(not funcStopCondition())do wait(delay)funcToRetry()end end polly.retryWhileNil=function(funcToRetry,delay)local response=funcToRetry()local i=0 local increase=5 local maxWait=60 delay=delay or increase while(response==nil)do i=i+1 wait(delay)response=funcToRetry()if(delay+i*increase<maxWait)then delay=delay+i*increase end end return response end if(web==nil)then web={}end function web.printUsage()print("Usage:")print("web.getToFile<url><filename>")end function web.request(sUrl)http.request(sUrl,nil,nil,false)local fired,ok=false,false local response,err='','' local fOk=function(fUrl,fHandle)fired=true ok=true response=fHandle end local fFail=function(fUrl,fErr,fHandle)fired=true ok=false response=fHandle err=fErr end once{event="http_success",f=fOk,filter=function(fUrl)return fUrl==sUrl end}once{event="http_failure",f=fFail,filter=function(fUrl)return fUrl==sUrl end}waitUntil(function()return fired end)off("http_success",fOk)off("http_failure",fFail)return ok,response,err end function web.get(sUrl)log.logVerbose("Connecting to ",sUrl,"...")local fired,ok=false,false local err,response='',nil local checkF=once{event="http_check",f=function(fUrl,fOk,fErr)fired=true ok=fOk err=fErr end,filter=function(fUrl)return fUrl==sUrl end}if(not http.checkURLAsync(sUrl))then log.logError('web.get ',sUrl,' is invalid')off("http_check",checkF)return nil end waitUntil(function()return fired end)if not ok then log.logError('web.get ',sUrl,' not OK')if err then printError(err)end return nil end ok,response,err=web.request(sUrl)if not ok then log.logError('web.get ',sUrl,' did not respond')if err then printError(err)end return nil end if not response then return nil end local sResponse=response.readAll()response.close()return sResponse end function web.getToFile(...)local tArgs={...}if #tArgs<2 then web.printUsage()return end if not http then printError("wget requires http API")printError("Set http_enable to true in ComputerCraft.cfg")return end local sUrl=tArgs[1] local sFile=tArgs[2] local sPath=shell.resolve(sFile)local res=web.get(sUrl)if res then files.write(sPath,res)log.logVerbose("Downloaded as ",sFile)end return res end if(stateH==nil)then stateH={}end stateH.id=os.getComputerID()state=state or{}stateH.init=function(params)params=params or{}state={id=stateH.id,sid=tostring(stateH.id),name=tostring(stateH.id),status=params.status or 'pending',types=params.types or{},elegibleTypes=params.elegibleTypes or{},spec={location=nil,facing='unknown',action=nil,network=network.addr},config={location={autoUpdate=params.autoUpdateLocation or false}},events={},data={}}return state end stateH.addType=function(newType)if(not linq:contains(state.types,newType))then table.insert(state.types,newType)queue('state_type_added',newType)end end stateH.removeType=function(existingType)if(linq:contains(state.types,existingType))then linq:where(state.types,function(k,v)return v==existingType end):remove()queue('state_type_removed',existingType)end end function stateH.onStateTypeAdded(name,callback)on({event='state_type_added',filter=function(t)return t==name end,once=false,f=callback})if(linq:contains(state.types,name))then add(function()callback()end)end end stateH.save=function()files.writeJson('state.json',state)end stateH.load=function()state=files.readJson('state.json')return state end function receiveRequest(path,actionFunc,timeout)return receive(path,actionFunc,true,timeout)end function receiveResponse(path,actionFunc,timeout)return receive(path,actionFunc,false,timeout)end function _doesPathMatchPattern(path,pathPattern)local pathParts=string.split(path,'/')pathPattern=type(pathPattern)=='table' and pathPattern or string.split(pathPattern,'/')if(#pathParts~=#pathPattern)then return false end for k,v in ipairs(pathParts)do if(pathPattern[k]~='*' and v~=pathPattern[k])then return false end end return true end function receive(path,actionFunc,isRequest,timeout)local filterType=(isRequest or nil==isRequest)and 'REQUEST' or 'RESPONSE' local pathPattern=type(path)=='table' and path or string.split(path,'/')local callbackIntermediary=function(message,sender)actionFunc(message,string.split(message.url,'/'))end local filterFunction=function(sender,message,protocol)return message.type==filterType and _doesPathMatchPattern(message.url,pathPattern)end add(function()waitUntil(function()return state==nil or state.status~='podinitializing' end)network.receiveMany(callbackIntermediary,timeout,filterFunction)end)end if(election==nil)then election={}end election.elections={}function election.startElection(electionType)if(linq:contains(election.elections,electionType))then return false end table.insert(election.elections,electionType)local elected=false local isElegible=linq:contains(state.elegibleTypes,electionType)if(not isElegible)then network.broadcast({type='REQUEST',method='GET',url='/election/'..electionType,body={id=-1,electionType=electionType}})else local candidates=election.lookupCandidates(electionType)if(not linq:any(candidates))then log.logVerbose('No response on election ',electionType,',electing self')if(not linq:contains(state.types,electionType))then stateH.addType(electionType)end network.addAddress(electionType,state.id)network.broadcast({type='REQUEST',method='POST',url='/election/'..electionType..'/elected',body={id=state.id,electionType=electionType}})elected=true queue('elected',{self=true,electionType=electionType,id=state.id})end end linq:where(election.elections,electionType):take(1):remove()return elected end function election.lookupCandidates(electionType)local responses={}local electionUrl='/election/'..electionType receiveResponse(electionUrl,function(okResponse)if(okResponse==nil or okResponse.body.id==nil)then return end table.insert(responses,okResponse.body.id)end,2)network.broadcast({type='REQUEST',method='GET',url=electionUrl,body={id=state.id,electionType=electionType}})wait(2,function()return #responses>0 end)return responses end function election.whenElected(electionType,callbackFunc)add(function()if(linq:contains(state.types,electionType))then callbackFunc()end return on{event="elected",filter=function(election)return election.electionType==electionType and election.self end,f=callbackFunc}end)end receiveRequest('/election/*',function(request,urlParts)local isElegible=linq:contains(state.elegibleTypes,request.body.electionType)if(isElegible and request.body.id<state.id)then network.respond(request,{id=state.id})election.startElection(request.body.electionType)end end)receiveRequest('/election/*/elected',function(request,urlParts)network.clearAddress(request.body.electionType)network.addAddress(request.body.electionType,request.body.id)linq:where(election.elections,request.body.electionType):take(1):remove()if(request.body.id~=state.id)then stateH.removeType(request.body.electionType)end queue('elected',{self=false,electionType=request.body.electionType,id=request.body.id})log.logVerbose(request.body.electionType,' elected: ',request.body.id)end)if(networkHandling==nil)then networkHandling={}end networkHandling.discovery={inProgress=false,lastExecuted=nil,refreshInterval=60}networkHandling.updateHandlerRunning=false function networkHandling.discoveryLoop()if(networkHandling.updateHandlerRunning)then return end networkHandling.updateHandlerRunning=true while(linq:contains(state.types,'network'))do wait(networkHandling.discovery.refreshInterval)networkHandling.startNetworkDiscovery()end networkHandling.updateHandlerRunning=false end add(function()for k,typeName in ipairs(state.types)do network.addAddress(typeName,state.id)end network.onNetworkAddressRemoved('network',function(eventObj)if(network.hasModem and not eventObj.anyLeft)then if(not networkHandling.lookup('network'))then election.startElection('network')end end end)stateH.onStateTypeAdded('network',function()networkHandling.discoveryLoop()end)wait(math.random(1,2))if(network.hasModem and not getNetworkMap())then wait(3)networkHandling.startNetworkDiscovery()end state.status='running' end)function networkHandling.startNetworkDiscovery()log.logVerbose('Start network discovery')if(linq:contains(state.types,'network'))then log.logVerbose('I\'m already network')networkHandling.buildNetworkMap()log.logVerbose('Network discovery done')return end local success=getNetworkMap()if(not success)then election.startElection('network')wait(5,function()return network.hasAddress('network')end)networkHandling.startNetworkDiscovery()end log.logVerbose('network leaders:',string.join(network.getIds('network'),','))log.logVerbose('Network discovery done')end function getNetworkMap()log.logVerbose('getNetworkMap')if(linq:contains(state.types,'network'))then networkHandling.buildNetworkMap()return true end local retries=0 local networkHost=network.getCurrentAddress('network')or networkHandling.lookup('network')while(networkHost~=nil and networkHandling.testPodAlive('network')and retries<5)do retries=retries+1 local networkMapRequest=network.get('network','/network')if(networkMapRequest~=nil and networkMapRequest.body~=nil)then log.logVerbose('Updated network map')networkHandling.updateNetwork(networkMapRequest.body)return true end log.logWarning('Got empty network map,retry in 1 second')network.markAddressDropped(networkHost)wait(1)networkHost=network.getCurrentAddress('network')end return false end function networkHandling.buildNetworkMap()log.logVerbose('Build network map')networkHandling.discovery.inProgress=true local timeout=2 local addressMap={pod={state.id}}for k,typ in ipairs(state.types)do addressMap[typ]=addressMap[typ] or{}table.insert(addressMap[typ],state.id)end receiveResponse('/network/ping',function(response)local newAddr=response.body if(newAddr==nil or type(newAddr)~='table')then return end if(not linq:contains(addressMap.pod,newAddr.id))then table.insert(addressMap.pod,newAddr.id)for k,typ in ipairs(newAddr.types)do addressMap[typ]=addressMap[typ] or{}table.insert(addressMap[typ],newAddr.id)end end end,timeout)network.broadcast({type='REQUEST',method='GET',url='/network/ping'})wait(timeout)local anyChange=false local seenTypes={}for typ,ids in pairs(addressMap)do table.insert(seenTypes,typ)local existingIds=network.getIds(typ)for k,existingId in ipairs(existingIds)do if(not linq:contains(ids,existingId))then anyChange=true network.removeAddress(typ,existingId)end end for k,newId in ipairs(ids)do if(not linq:contains(existingIds,newId))then anyChange=true network.addAddress(typ,newId)end end end for typ in pairs(network.getAddresses())do if(not linq:contains(seenTypes,typ))then network.clearAddress(typ)end end if(anyChange)then network.broadcast({type='REQUEST',method='POST',url='/network/update',body=network.getAddresses()})end local anyDuplicateNetworkLeaders=linq:any(addressMap.network or{},function(k,id)return id~=state.id end)if(anyDuplicateNetworkLeaders)then election.startElection('network')end networkHandling.discovery.inProgress=false end function networkHandling.updateNetwork(map)network.addr=map state.spec.network=network.addr end function networkHandling.lookup(name)if(not network.hasModem)then return nil end if(network.hasAddress(name))then return network.getAddress(name)end local responses={}local received=false local url='/network/lookup/'..name receiveResponse(url,function(response)response=response.body if(response==nil or linq:contains(responses,response))then return end table.insert(responses,response)received=true end,2)network.broadcast({type='REQUEST',method='GET',url=url})wait(2,function()return received end)for k,response in ipairs(responses)do if(response==state.id or networkHandling.testPodAlive(response))then network.addAddress(name,response)if(response==state.id and not linq:contains(state.types,name))then stateH.addType(name)end end end return network.getAddress(name)end function networkHandling.testPodAlive(address)if(address==nil)then return false end local health=network.get(address,'/health',nil,nil,2)return health~=nil end receiveRequest('/health',function(request)network.respond(request,true)end)receiveRequest('/network',function(request)local condition=function()return not networkHandling.discovery.inProgress end wait(5,condition)if(condition())then network.respond(request,network.getAddresses())end end)receiveRequest('/network/update',function(request)networkHandling.updateNetwork(request.body)end)receiveRequest('/network/lookup/*',function(request,urlParts)waitUntil(function()return not networkHandling.discovery.inProgress end)local r=network.getAddress(urlParts[3])if(r~=nil and r.id~=nil)then network.respond(request,r.id)end end)receiveRequest('/network/ping',function(request)network.respond(request,{types=state.types,id=state.id})debounce('/network/ping',function()election.startElection('network')end,networkHandling.discovery.refreshInterval*3+1)end)election.whenElected('network',function()networkHandling.buildNetworkMap()end)if(cachehandling==nil)then cachehandling={}end cachehandling.updateChecked=false function updateFileCache()if(not network.hasAddress('cache'))then return end local url='/luacache/'..thisFile local responseFile=network.get('cache',url)if(responseFile==nil)then error('Got empty response on ',url)end log.logVerbose('Found ',thisFile,' file from cache')files.write('startup.lua',responseFile.body.content)state.data.cacheupdate=os.time('local')stateH.save()log.logWarning('Rebooting for cache...')wait(1)os.reboot()end add(function()wait(30,function()return cachehandling.updateChecked or(network.hasAddress('cache')and not linq:contains(state.types,'cache'))end)if(not(network.hasAddress('cache')and not linq:contains(state.types,'cache')))then return end local lastUpdated=state.data.cacheupdate or 0 local url='/luacache/'..thisFile..'/lastChecked' local response=network.get('cache',url)if(response~=nil)then local diff=response.body-lastUpdated if(diff>0.002)then wait(2)updateFileCache()end else log.logVerbose('Cache server did not respond to ',url)end end)receiveRequest('/luacache',function(message,urlParts)if(linq:contains(state.types,'cache'))then return end log.logInfo('Received message ',message.url,' from ',message.headers.sender)if(not network.hasAddress('cache'))then network.addAddress('cache',message.headers.sender)end if(linq:contains(message.body,thisFile))then updateFileCache()end log.logVerbose('Message handling ',message.url,' from ',message.headers.sender,' done')end)add(function()if(not linq:contains(state.elegibleTypes,'cache'))then return nil end cachehandling.indexFile='https://raw.githubusercontent.com/latens/bug-free-octo-couscous-index/refs/heads/main/index.prod.json' cachehandling.cacheConfigFile='cache.json' cachehandling.refreshInterval=60 cachehandling.cache=files.readJson(cachehandling.cacheConfigFile)or{files={},lastChecked=0,latestChanges={},}function cachehandling.updateCache()local now=os.time('local')log.logVerbose('Update cache ',now)local latestChanges={}local index=polly.retryWhileNil(function()return web.get(cachehandling.indexFile)end)index=textutils.unserialiseJSON(index)for _,file in ipairs(index.files or index)do if(cachehandling.cache.files[file.name]==nil)then cachehandling.cache.files[file.name]={diskPath='cache/'..file.name,changeID=file.changeID-1,name=file.name}end local cachedFile=cachehandling.cache.files[file.name] if(cachedFile.changeID<file.changeID)then table.insert(latestChanges,cachedFile.name)cachedFile.changeID=file.changeID web.getToFile((index.baseUrl or 'https://raw.githubusercontent.com/latens/bug-free-octo-couscous-index/refs/heads/main/files/prod/')..file.name,cachedFile.diskPath)cachedFile.updatedAt=now end end cachehandling.cache.latestChanges=latestChanges cachehandling.cache.lastChecked=now files.writeJson(cachehandling.cacheConfigFile,cachehandling.cache)end function cachehandling.getCachedFileContent(name)return files.read(cachehandling.cache.files[name].diskPath)end function cachehandling.getCachedContent()local response={}for name,opts in pairs(cachehandling.cache.files)do table.insert(response,{name=name,content=cachehandling.getCachedFileContent(name)})end return response end network.onNetworkAddressRemoved('cache',function(eventObj)if(not eventObj.anyLeft)then if(not networkHandling.lookup('cache'))then election.startElection('cache')end end end)cachehandling.updateHandlerRunning=false function cachehandling.cacheUpdateHandler()if(cachehandling.updateHandlerRunning)then return end cachehandling.updateHandlerRunning=true try(function()repeat wait(cachehandling.refreshInterval)cachehandling.updateCache()local changes=cachehandling.cache.latestChanges if(linq:any(changes))then if(network.hasModem)then log.logInformation('Broadcasting file updates ')network.broadcast({type='REQUEST',method='POST',url='/luacache',body=changes})wait(5)else log.logInformation('Update found')wait(1)end if(linq:contains(changes,thisFile))then local content=files.read('cache/'..thisFile)files.write('startup.lua',content)log.logWarning('Rebooting...')os.reboot()end end cachehandling.cache.latestChanges={}until(not linq:contains(state.types,'cache'))end)cachehandling.updateHandlerRunning=false end stateH.onStateTypeAdded('cache',function()cachehandling.cacheUpdateHandler()end)receiveRequest('/luacache/*/lastChecked',function(request,urlParts)local fileName=urlParts[2] network.respond(request,cachehandling.cache.files[fileName].updatedAt)end)receiveRequest('/luacache',function(request)network.respond(request,cachehandling.getCachedContent())end)receiveRequest('/luacache/*',function(request,urlParts)local fileName=urlParts[2] local content=cachehandling.getCachedFileContent(fileName)network.respond(request,{name=fileName,content=content})end)end)thisFile='beacon.lua' print('v1.1')settings.load('settings.json')stateEvents=settings.get('events')or{}if(not stateH.load())then stateH.init({types={'beacon'},elegibleTypes={'beacon','network'}})end network.addr=state.spec.network add(function()wait(5)for k,v in pairs(state.types)do print(v)end end)add(function()print('')wait(15)for k,v in pairs(state.types)do print(v)end end)if(network.addr['cache']~=nil)then print('remembered cache!')end oldState=state.status state.status='podinitializing' log.setLoglevel('information')receiveRequest('/reset',function(request)settings.clear()settings.save('settings.json')os.reboot()end)add(function()wait(math.random(2,3))networkHandling.startNetworkDiscovery()end)add(function()waitUntil(function()return linq:contains(state.types,'network')end)twrap.right()twrap.right()twrap.right()twrap.right()end)run(function()state.status=oldState~='podinitializing' and oldState or 'running' oldState=nil while(true)do settings.set('events',stateEvents)settings.set('state',state)settings.save('settings.json')wait(2)end end)--
